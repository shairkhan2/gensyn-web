<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gensyn Tracker - Real-time Network Stats</title>
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <header>
    <h1>🏆 Gensyn Tracker</h1>
    <button id="theme-toggle" aria-label="Toggle dark/light mode">🌙</button>
  </header>
  <div id="top-rewards-banner">
    <div id="rewards-slider"></div>
  </div>
      <div id="announcement" class="announcement">
      <div class="announcement-content">
        <div class="owner-info">
          <span class="owner-title">Owner of Site</span>
          <div class="telegram-link">
            <span class="telegram-icon">📱</span>
            <a href="https://t.me/Shair25" target="_blank" class="owner-name">SHAIR</a>
          </div>
        </div>
      </div>
      <button id="close-announcement" aria-label="Close announcement">&times;</button>
    </div>
    
    <!-- Email Modal -->
    <div id="email-modal" class="email-modal">
      <div class="email-modal-content">
        <div class="email-modal-header">
          <h3>💾 Save Peers as JSON</h3>
          <button class="close-modal" onclick="closeEmailModal()">&times;</button>
        </div>
        <div class="email-modal-body">
          <p>Save or load your peers:</p>
          <div class="email-input-group">
            <input type="text" id="file-name" placeholder="my-peers" class="email-input">
            <button onclick="savePeersToFile()" class="email-btn save-btn">💾 Save as JSON</button>
            <button onclick="loadPeersFromFile()" class="email-btn load-btn">📥 Load JSON</button>
          </div>
          <div id="email-status" class="email-status"></div>
        </div>
      </div>
    </div>
    

  <main>
    <section id="stats">
      <div class="stats-header">
        <h2>🌐 Network Stats</h2>
        <span class="last-updated" id="stats-last-updated"></span>
      </div>
      <div id="stats-content">
        <p>Loading stats...</p>
      </div>
    </section>
    <section id="saved-peers">
      <div class="saved-peers-header">
        <h2>My Saved Peers</h2>
        <div class="inline-summary" style="position: absolute; left: 50%; transform: translateX(-50%); display: inline-flex !important; flex-direction: row !important; align-items: center !important; justify-content: center !important; gap: 0.5rem; padding: 0.4rem 0.8rem; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2)) !important; border-radius: 15px; border: 1px solid rgba(255, 255, 255, 0.2) !important; backdrop-filter: blur(10px); z-index: 10; min-width: 100px; flex-wrap: nowrap !important; box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3) !important; animation: float 3s ease-in-out infinite; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">
          <span class="summary-icon" style="font-size: 1rem !important; color: var(--primary-color) !important; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important; margin-right: 0.2rem;">🎁</span>
          <span class="summary-value" id="total-rewards" style="font-size: 0.9rem !important; font-weight: 700 !important; color: var(--primary-color) !important; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important; min-width: 2rem; text-align: center; margin-right: 0.5rem;">0</span>
          <span class="summary-icon" style="font-size: 1rem !important; color: var(--primary-color) !important; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important; margin-right: 0.2rem;">🏆</span>
          <span class="summary-value" id="total-wins" style="font-size: 0.9rem !important; font-weight: 700 !important; color: var(--primary-color) !important; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important; min-width: 2rem; text-align: center; margin-right: 0.5rem;">0</span>
        </div>
        <div class="saved-peers-controls" style="display: flex; flex-direction: row; align-items: center; gap: 0.5rem;">
          <button id="refresh-btn" class="email-sync-btn-small" aria-label="Refresh data" title="Refresh all data">
            <span class="refresh-icon">🔄</span>
            <span class="refresh-text">Refresh</span>
          </button>
          <button onclick="openEmailModal()" class="email-sync-btn-small">
            💾 Saved
          </button>
        </div>
      </div>
      <div id="saved-peers-content">
        <p>No saved peers yet. Search for peers to save them!</p>
      </div>
    </section>
    <section id="peer-search">
      <h2>🔍 Search Peer</h2>
      <form id="search-form">
        <div class="search-input-group">
          <input type="text" id="search-input" placeholder="Enter peer name or ID" required>
          <button type="submit">🔍 Search</button>
        </div>
        <div class="search-tips">
          <small>💡 Tips: Try peer names or peer IDs (Qm...)</small>
        </div>
      </form>
      <div id="peer-detail" class="peer-detail" style="display:none;"></div>
    </section>
    <section id="leaderboard">
      <div class="leaderboard-header">
        <h2>🏆 Leaderboard</h2>
        <span class="last-updated" id="leaderboard-last-updated"></span>
      </div>
      <div id="leaderboard-content">
        <p>Loading leaderboard...</p>
      </div>
    </section>
  </main>
  <footer>
    <p>&copy; 2024 Gensyn Tracker - Real-time Network Monitoring</p>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
  <script>
    // CORS Proxy with fallback
    async function fetchWithCorsProxy(url) {
      console.log('Fetching URL:', url);
      
      // First try our own proxy API
      try {
        console.log('Trying our own proxy API');
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        const response = await fetch(`/api/proxy?url=${encodeURIComponent(url)}`, {
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        console.log('Proxy response status:', response.status);
        
        if (response.ok) {
          try {
            const data = await response.json();
                              console.log('Success with our own proxy API');
                  console.log('Response data:', data);
                  console.log('Response data type:', typeof data);
                  console.log('Response data keys:', data ? Object.keys(data) : 'null/undefined');
                  console.log('Raw response text:', JSON.stringify(data));
                  console.log('=== PROXY DEBUG END ===');
                  return data;
          } catch (jsonError) {
            console.error('Failed to parse JSON from proxy:', jsonError);
            const text = await response.text();
            console.error('Raw response text:', text.substring(0, 200));
            throw new Error('Invalid JSON response from proxy');
          }
        } else {
          console.log('Proxy response not ok:', response.status, response.statusText);
        }
      } catch (error) {
        console.log('Failed with our own proxy API:', error.message);
      }
      
      // Fallback to external proxies if our proxy fails
      const proxies = [
        'https://cors.bridged.cc/',
        'https://api.allorigins.win/raw?url=',
        'https://thingproxy.freeboard.io/fetch/'
      ];
      
      for (const proxy of proxies) {
        try {
          console.log(`Trying external proxy: ${proxy}`);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
          
          const response = await fetch(proxy + url, {
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            },
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          console.log(`External proxy response status:`, response.status);
          
          if (response.ok) {
            const data = await response.json();
            console.log(`Success with external proxy: ${proxy}`);
            return data;
          } else {
            console.log(`External proxy failed with status:`, response.status);
          }
        } catch (error) {
          console.log(`Failed with external proxy ${proxy}:`, error.message);
          continue;
        }
      }
      
      // If all proxies fail, try direct fetch as last resort
      try {
        console.log('Trying direct fetch as last resort...');
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('Success with direct fetch');
          return data;
        }
      } catch (directError) {
        console.log('Direct fetch also failed:', directError.message);
      }
      
      throw new Error('All proxies and direct fetch failed');
    }

    // Set default theme to dark
    document.body.classList.add('dark-mode');
    
    // Force cache refresh for debugging
    console.log('=== DEBUG VERSION 1.3 ===');
    console.log('Timestamp:', new Date().toISOString());
    console.log('Cache bust timestamp:', Date.now());
    
    // Test function to verify deployment
    window.testDeployment = function() {
      console.log('DEPLOYMENT TEST: Function is working!');
      return 'SUCCESS';
    };
    
    // Dark/Light mode toggle
    const themeToggle = document.getElementById('theme-toggle');
    themeToggle.textContent = '☀️'; // Start with sun icon since dark mode is default
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      themeToggle.textContent = document.body.classList.contains('dark-mode') ? '☀️' : '🌙';
    });
    // Announcement close
    document.getElementById('close-announcement').onclick = function() {
      document.getElementById('announcement').style.display = 'none';
    };

    // Refresh functionality
    document.getElementById('refresh-btn').addEventListener('click', async function() {
      console.log('Manual refresh triggered');
      
      const refreshBtn = document.getElementById('refresh-btn');
      const refreshIcon = refreshBtn.querySelector('.refresh-icon');
      const refreshText = refreshBtn.querySelector('.refresh-text');
      
      // Start loading animation
      refreshBtn.disabled = true;
      refreshIcon.textContent = '🔄';
      refreshText.textContent = 'Loading...';
      refreshBtn.style.background = 'linear-gradient(135deg, #ff6b6b, #ffa500)';
      refreshBtn.style.transform = 'scale(0.95)';
      
      // Add a small delay to show the animation
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Clear rate limits to force fresh data
      localStorage.removeItem('rateLimit_networkStats');
      localStorage.removeItem('rateLimit_leaderboard');
      
      try {
        // Refresh all data
        await Promise.all([
          fetchNetworkStats(),
          fetchLeaderboard()
        ]);
        
        // Refresh saved peers data
        await refreshSavedPeers();
        
        // Show success state with Gen Z style
        refreshBtn.style.transform = 'scale(1.05)';
        refreshIcon.textContent = '🔥';
        refreshText.textContent = 'Lit!';
        refreshBtn.style.background = 'linear-gradient(135deg, #00ff88, #00d4aa)';
        
        setTimeout(() => {
          refreshIcon.textContent = '🔄';
          refreshText.textContent = 'Refresh';
          refreshBtn.style.background = 'linear-gradient(135deg, var(--primary-color), var(--secondary-color))';
          refreshBtn.style.transform = 'scale(1)';
          refreshBtn.disabled = false;
        }, 1500);
        
      } catch (error) {
        console.error('Refresh failed:', error);
        
        // Show error state
        refreshBtn.style.transform = 'scale(0.95)';
        refreshIcon.textContent = '💀';
        refreshText.textContent = 'Oops!';
        refreshBtn.style.background = 'linear-gradient(135deg, #ff4757, #ff3838)';
        
        setTimeout(() => {
          refreshIcon.textContent = '🔄';
          refreshText.textContent = 'Refresh';
          refreshBtn.style.background = 'linear-gradient(135deg, var(--primary-color), var(--secondary-color))';
          refreshBtn.style.transform = 'scale(1)';
          refreshBtn.disabled = false;
        }, 2000);
      }
    });

    // Peer search functionality
    document.getElementById('search-form').addEventListener('submit', async function(e) {
      e.preventDefault();
      const query = document.getElementById('search-input').value.trim();
      if (!query) return;
      let peerData = null;
      let peerId = null;
      let eoa = null;
      let isEoa = false;
      const detailDiv = document.getElementById('peer-detail');
      detailDiv.style.display = 'block';
      detailDiv.textContent = 'Loading...';
      // Helper: fetch EOA from contract
      async function fetchEoaForPeer(peerId) {
        try {
          console.log('Fetching EOA for peerId:', peerId);
          const provider = new ethers.JsonRpcProvider("https://gensyn-testnet.g.alchemy.com/v2/TD5tr7mo4VfXlSaolFlSr3tL70br2M9J");
          const contract = new ethers.Contract(
            "0xFaD7C5e93f28257429569B854151A1B8DCD404c2",
            [
              {
                "name": "getEoa",
                "type": "function",
                "stateMutability": "view",
                "inputs": [{ "name": "peerIds", "type": "string[]" }],
                "outputs": [{ "name": "", "type": "address[]" }]
              }
            ],
            provider
          );
          const addresses = await contract.getEoa([peerId]);
          console.log('Contract response:', addresses);
          const eoa = addresses[0];
          console.log('EOA address:', eoa);
          return eoa;
        } catch (error) {
          console.error('Error fetching EOA from contract:', error);
          return null;
        }
      }
      // If input looks like an EOA address
      if (query.startsWith('0x') && query.length === 42) {
        isEoa = true;
        eoa = query;
        
        try {
                  // Search for peer info for this EOA address in the leaderboard
        console.log("Searching leaderboard for EOA address");
        const data = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/leaderboard');
        const entries = data.entries || [];
        const matchingPeer = entries.find(peer => peer.eoa && peer.eoa.toLowerCase() === eoa.toLowerCase());
        
        if (matchingPeer && matchingPeer.peerName) {
          // Found peer info for this EOA
          detailDiv.innerHTML = `
            <div class="peer-card">
              <div class="peer-header">
                <div class="peer-avatar">${matchingPeer.peerName.charAt(0).toUpperCase()}</div>
                <div class="peer-info">
                  <h3 class="peer-name">${matchingPeer.peerName}</h3>
                  <span class="peer-status ${matchingPeer.online ? 'online' : 'offline'}">${matchingPeer.online ? '🟢 Online' : '🔴 Offline'}</span>
                </div>
              </div>
              <div class="peer-stats">
                <div class="stat-item-cool">
                  <span class="stat-icon">🏆</span>
                  <span class="stat-label-cool">Reward</span>
                  <span class="stat-value-cool">${matchingPeer.reward.toLocaleString()}</span>
                </div>
                <div class="stat-item-cool">
                  <span class="stat-icon">📊</span>
                  <span class="stat-label-cool">Score</span>
                  <span class="stat-value-cool">${matchingPeer.score.toLocaleString()}</span>
                </div>
              </div>
              <div class="peer-details">
                <div class="detail-item">
                  <span class="detail-label">Peer ID</span>
                  <span class="detail-value">${matchingPeer.peerId}</span>
                </div>
                <div class="detail-item">
                  <span class="detail-label">EOA Address</span>
                  <span class="detail-value">${eoa}</span>
                </div>
              </div>
              <div class="peer-footer">
                <span class="success-badge">✓ Found via leaderboard search</span>
              </div>
            </div>
          `;
        } else {
          detailDiv.innerHTML = `
            <div class="peer-card">
              <strong>EOA Address:</strong> ${eoa}<br>
              <span style='color:orange'>⚠ No peer information found for this EOA address</span><br>
              <span style='color:gray'>This EOA address is not associated with any peer in the current data.</span>
            </div>
          `;
        }
        } catch (err) {
          detailDiv.innerHTML = `
            <div class="peer-card">
              <strong>EOA Address:</strong> ${eoa}<br>
              <span style='color:red'>Error fetching peer information: ${err.message}</span>
            </div>
          `;
        }
        return;
      }
      try {
        // If input looks like a peerId
        if (query.startsWith('Qm')) {
          // Fetch peer info from dashboard API
          peerData = await fetchWithCorsProxy(`https://dashboard.gensyn.ai/api/v1/peer?id=${encodeURIComponent(query)}`);
          peerId = peerData.peerId;
        } else {
          // Assume it's a peer name, fetch info
          peerData = await fetchWithCorsProxy(`https://dashboard.gensyn.ai/api/v1/peer?name=${encodeURIComponent(query)}`);
          peerId = peerData.peerId;
        }
        // Now fetch EOA from contract
        eoa = await fetchEoaForPeer(peerId);
        
        // If contract call failed, try to find EOA in leaderboard data
        if (!eoa || eoa === '0x0000000000000000000000000000000000000000') {
          console.log('Contract call failed or returned zero address, trying leaderboard search...');
          try {
            const leaderboardData = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/leaderboard');
            const entries = leaderboardData.entries || [];
            const matchingPeer = entries.find(peer => peer.peerId === peerId);
            if (matchingPeer && matchingPeer.eoa) {
              eoa = matchingPeer.eoa;
              console.log('Found EOA in leaderboard:', eoa);
            }
          } catch (err) {
            console.error('Error searching leaderboard for EOA:', err);
          }
        }
        
        // Add EOA to peerData before saving
        peerData.eoa = eoa;
        
        // Save peer data automatically
        savePeerData(peerData);
        
        // Validate peer data before displaying
        if (!peerData || !peerData.peerName) {
          throw new Error('Invalid peer data received');
        }
        
        detailDiv.innerHTML = `
          <div class="peer-card">
            <div class="peer-header">
              <div class="peer-avatar">${peerData.peerName.charAt(0).toUpperCase()}</div>
              <div class="peer-info">
                <h3 class="peer-name">${peerData.peerName}</h3>
                <span class="peer-status ${peerData.online ? 'online' : 'offline'}">${peerData.online ? '🟢 Online' : '🔴 Offline'}</span>
              </div>
            </div>
            <div class="peer-stats">
              <div class="stat-item-cool">
                <span class="stat-icon">🏆</span>
                <span class="stat-label-cool">Reward</span>
                <span class="stat-value-cool">${peerData.reward.toLocaleString()}</span>
              </div>
              <div class="stat-item-cool">
                <span class="stat-icon">📊</span>
                <span class="stat-label-cool">Score</span>
                <span class="stat-value-cool">${peerData.score.toLocaleString()}</span>
              </div>
            </div>
            <div class="peer-details">
              <div class="detail-item">
                <span class="detail-label">Peer ID</span>
                <span class="detail-value">${peerData.peerId}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">EOA Address</span>
                <span class="detail-value">${eoa || 'Not available'}</span>
              </div>
            </div>
            <div class="peer-footer">
              <span class="success-badge">✓ Found via smart contract & Saved!</span>
            </div>
          </div>
        `;
      } catch (err) {
        console.error('Search error:', err);
        detailDiv.innerHTML = `
          <div class="peer-card">
            <div class="peer-header">
              <div class="peer-avatar">❌</div>
              <div class="peer-info">
                <h3 class="peer-name">Search Failed</h3>
                <span class="peer-status offline">🔴 Error</span>
              </div>
            </div>
            <div class="peer-details">
              <div class="detail-item">
                <span class="detail-label">Search Query</span>
                <span class="detail-value">${query}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">Error</span>
                <span class="detail-value" style="color: #ff6b6b;">${err.message}</span>
              </div>
            </div>
            <div class="peer-footer">
              <span style="color: #ffa500;">⚠️ Try searching with a valid peer name or ID</span>
            </div>
          </div>
        `;
      }
    });

    // Move leaderboard to a sidebar on the right and show only top 10 peers with name, reward, and score
    // Update HTML structure
    const main = document.querySelector('main');
    if (!document.getElementById('main-content')) {
      const mainContent = document.createElement('div');
      mainContent.id = 'main-content';
      mainContent.style.display = 'flex';
      mainContent.style.gap = '2rem';
      mainContent.innerHTML = `
        <div id="main-sections" style="flex:1; min-width:0;"></div>
        <aside id="leaderboard-aside" style="width:260px; min-width:180px;"></aside>
      `;
      // Move all sections except leaderboard into main-sections
      const stats = document.getElementById('stats');
      const savedPeers = document.getElementById('saved-peers');
      const peerSearch = document.getElementById('peer-search');
      mainContent.querySelector('#main-sections').appendChild(savedPeers);
      mainContent.querySelector('#main-sections').appendChild(peerSearch);
      
      // Move stats to leaderboard aside and make it small
      const statsSection = document.getElementById('stats');
      statsSection.style.marginBottom = '1rem';
      mainContent.querySelector('#leaderboard-aside').insertBefore(statsSection, mainContent.querySelector('#leaderboard-aside').firstChild);
      // Move leaderboard section into aside
      const leaderboard = document.getElementById('leaderboard');
      mainContent.querySelector('#leaderboard-aside').appendChild(leaderboard);
      main.innerHTML = '';
      main.appendChild(mainContent);
    }
    // Leaderboard fetch and click-to-detail (Gensyn style) with caching and rate limiting
    async function fetchLeaderboard() {
      const leaderboardDiv = document.getElementById('leaderboard-content');
      console.log('Fetching leaderboard...');
      
      // Try to get cached data first
      const cachedData = getCachedData('leaderboard');
      console.log('Cached data:', cachedData ? 'Found' : 'Not found');
      
      if (cachedData) {
        console.log('Displaying cached leaderboard data');
        displayLeaderboard(cachedData);
      }
      
      // Check rate limit for leaderboard (15 min interval)
      if (isRateLimited('leaderboard') && cachedData) {
        console.log('Leaderboard rate limited, using cached data');
        return;
      }
      
      // Only show loading if no cached data
      if (!cachedData) {
        leaderboardDiv.innerHTML = 'Loading leaderboard...';
      }
      
      try {
        console.log('Fetching leaderboard with fallback proxies...');
        const data = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/leaderboard');
        console.log('Leaderboard data received:', data);
        
        // Cache the new data and set rate limit
        setCachedData('leaderboard', data);
        setRateLimit('leaderboard');
        
        // Update last updated time
        const now = new Date();
        document.getElementById('leaderboard-last-updated').textContent = `Last updated: ${now.toLocaleTimeString()}`;
        
        displayLeaderboard(data);
      } catch (err) {
        console.error('Leaderboard fetch error:', err);
        // Only show error if no cached data available
        if (!cachedData) {
          leaderboardDiv.innerHTML = '<span style="color:red">Error loading leaderboard.</span>';
        }
      }
    }
    
    function displayLeaderboard(data) {
      const leaderboardDiv = document.getElementById('leaderboard-content');
      const entries = (data.entries || []).slice(0, 10);
      
      if (!Array.isArray(entries) || entries.length === 0) {
        leaderboardDiv.innerHTML = '<span style="color:red">No leaderboard data found.</span>';
        return;
      }
      
              let table = `<div class='gensyn-leaderboard-title'>Top 10 (Gensyn Leaderboard)</div>`;
        table += `<table class='gensyn-leaderboard-table'><thead><tr><th>Rank</th><th>Peer ID</th><th>Wins</th><th>Rewards</th></tr></thead><tbody>`;
      entries.forEach((peer, idx) => {
        let rank, delta;
        if (idx === 0) { rank = '🥇'; delta = '▲1'; }
        else if (idx === 1) { rank = '🥈'; delta = '▼1'; }
        else if (idx === 2) { rank = '🥉'; delta = '▲1'; }
        else { rank = `#${idx + 1}`; delta = '–'; }
        // Shorten peerId for display
        const shortPeerId = peer.peerId.slice(0, 8);
        table += `<tr class='gensyn-leaderboard-row' data-peerid="${peer.peerId}">
          <td>${rank}</td>
          <td class='gensyn-peerid'>${shortPeerId}</td>
          <td>${peer.score.toLocaleString()}</td>
          <td>${peer.reward.toLocaleString()}</td>
        </tr>`;
      });
      table += '</tbody></table>';
      leaderboardDiv.innerHTML = table;
      
      // Add click listeners to rows
      document.querySelectorAll('.gensyn-leaderboard-row').forEach(row => {
        row.addEventListener('click', async function() {
          const peerId = this.getAttribute('data-peerid');
          document.getElementById('search-input').value = peerId;
          document.getElementById('search-form').dispatchEvent(new Event('submit'));
          window.scrollTo({ top: document.getElementById('peer-search').offsetTop - 20, behavior: 'smooth' });
        });
      });
    }
    
    // Data caching system with rate limiting
    const cacheKey = 'gensyn_cache_data';
    const cacheExpiry = 5 * 60 * 1000; // 5 minutes
    const rateLimitKey = 'gensyn_rate_limit';
    const rateLimitInterval = 15 * 60 * 1000; // 15 minutes for saved peers updates
    
    function getCachedData(key) {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const data = JSON.parse(cached);
        if (data[key] && Date.now() - data[key].timestamp < cacheExpiry) {
          return data[key].value;
        }
      }
      return null;
    }
    
    function setCachedData(key, value) {
      const cached = localStorage.getItem(cacheKey);
      const data = cached ? JSON.parse(cached) : {};
      data[key] = {
        value: value,
        timestamp: Date.now()
      };
      localStorage.setItem(cacheKey, JSON.stringify(data));
    }
    
    // Rate limiting functions
    function isRateLimited(key) {
      const rateLimit = localStorage.getItem(rateLimitKey);
      if (rateLimit) {
        const limits = JSON.parse(rateLimit);
        const lastCall = limits[key] || 0;
        const now = Date.now();
        return (now - lastCall) < rateLimitInterval;
      }
      return false;
    }
    
    function setRateLimit(key) {
      const rateLimit = localStorage.getItem(rateLimitKey);
      const limits = rateLimit ? JSON.parse(rateLimit) : {};
      limits[key] = Date.now();
      localStorage.setItem(rateLimitKey, JSON.stringify(limits));
    }
    
    // Fetch leaderboard on page load
    fetchLeaderboard();
    
    // --- Fix for network stats property and debugging ---
    async function fetchNetworkStats() {
      const statsDiv = document.getElementById('stats-content');
      // Try to get cached data first
      const cachedData = getCachedData('networkStats');
      const cachedRoundData = getCachedData('roundData');
      
      if (cachedData && cachedRoundData) {
        const value = cachedData.connected !== undefined ? cachedData.connected : cachedData.count;
        statsDiv.innerHTML = `
          <div class="stats-card">
            <div class="stat-item">
              <span class="stat-label">Nodes Connected</span>
              <span class="stat-value">${value ? value.toLocaleString() : '?'}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Current Round</span>
              <span class="stat-value">${cachedRoundData.round}</span>
            </div>
          </div>
        `;
      }
      
      // Check rate limit for network stats (15 min interval)
      if (isRateLimited('networkStats') && cachedData && cachedRoundData) {
        console.log('Network stats rate limited, using cached data');
        return;
      }
      
      try {
        // Fetch nodes connected
        const nodesData = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/nodes-connected');
        const value = nodesData.connected !== undefined ? nodesData.connected : nodesData.count;
        
        // Fetch round data
        const roundData = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/round-stage');
        
        // Cache both data sets
        setCachedData('networkStats', nodesData);
        setCachedData('roundData', roundData);
        setRateLimit('networkStats');
        
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        
        statsDiv.innerHTML = `
          <div class="stats-card">
            <div class="stat-item">
              <span class="stat-label">🟢 Nodes Connected</span>
              <span class="stat-value">${value ? value.toLocaleString() : '?'}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">🏆 Current Round</span>
              <span class="stat-value">${roundData.round}</span>
            </div>
          </div>
        `;
        
        // Update last updated time
        document.getElementById('stats-last-updated').textContent = `Last updated: ${timeString}`;
      } catch (err) {
        if (!cachedData) {
          statsDiv.innerHTML = '<span style="color:red">Error loading network stats.</span>';
        }
        console.error('Network stats error:', err);
      }
    }
    
    // Peer data management
    const savedPeersKey = 'gensyn_saved_peers';
    
    function savePeerData(peerData) {
      // Validate peer data before saving
      if (!peerData || !peerData.peerId || !peerData.peerName) {
        console.error('Invalid peer data:', peerData);
        return;
      }
      
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const now = new Date().toISOString();
      
      if (savedPeers[peerData.peerId]) {
        // Update existing peer with new data
        const oldData = savedPeers[peerData.peerId];
        const rewardChange = peerData.reward - oldData.reward;
        const scoreChange = peerData.score - oldData.score;
        
        savedPeers[peerData.peerId] = {
          ...peerData,
          lastUpdated: now,
          previousData: {
            reward: oldData.reward,
            score: oldData.score,
            lastUpdated: oldData.lastUpdated
          },
          changes: {
            reward: rewardChange,
            score: scoreChange
          }
        };
      } else {
        // New peer
        savedPeers[peerData.peerId] = {
          ...peerData,
          lastUpdated: now,
          previousData: null,
          changes: {
            reward: 0,
            score: 0
          }
        };
      }
      
      localStorage.setItem(savedPeersKey, JSON.stringify(savedPeers));
      displaySavedPeers();
    }
    
    function displaySavedPeers() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const container = document.getElementById('saved-peers-content');
      
      if (Object.keys(savedPeers).length === 0) {
        container.innerHTML = '<p>No saved peers yet. Search for peers to save them!</p>';
        // Clear totals when no peers
        document.getElementById('total-rewards').textContent = '0';
        document.getElementById('total-wins').textContent = '0';
        return;
      }
      
      // Calculate summary stats with error handling
      const totalRewards = Object.values(savedPeers).reduce((sum, peer) => {
        if (peer && typeof peer.reward === 'number') {
          return sum + peer.reward;
        }
        return sum;
      }, 0);
      
      const totalWins = Object.values(savedPeers).reduce((sum, peer) => {
        if (peer && typeof peer.score === 'number') {
          return sum + peer.score;
        }
        return sum;
      }, 0);
      
      // Update header summary
      const rewardsElement = document.getElementById('total-rewards');
      const winsElement = document.getElementById('total-wins');
      
      if (rewardsElement) {
        rewardsElement.textContent = totalRewards.toLocaleString();
      }
      
      if (winsElement) {
        winsElement.textContent = totalWins.toLocaleString();
      }
      
      console.log(`Updated totals: Rewards=${totalRewards}, Wins=${totalWins}`);
      
      const peerCount = Object.keys(savedPeers).length;
      let html = `<div class="saved-peers-grid" data-peer-count="${peerCount}">`;
      
      Object.values(savedPeers).forEach(peer => {
        // Skip invalid peers
        if (!peer || !peer.peerName || !peer.peerId) {
          console.error('Invalid peer data found:', peer);
          return;
        }
        
        const lastUpdated = new Date(peer.lastUpdated).toLocaleString();
        const rewardChange = peer.changes?.reward || 0;
        const scoreChange = peer.changes?.score || 0;
        
        html += `
          <div class="saved-peer-card" onclick="showSavedPeerDetails('${peer.peerId}')" style="cursor: pointer;">
            <div class="saved-peer-header">
              <div class="saved-peer-avatar">${peer.peerName.charAt(0).toUpperCase()}</div>
              <div class="saved-peer-info">
                <h4 class="saved-peer-name">${peer.peerName}</h4>
                <span class="saved-peer-status ${peer.online ? 'online' : 'offline'}">${peer.online ? '🟢 Online' : '🔴 Offline'}</span>
              </div>
              <button class="remove-peer-btn" onclick="event.stopPropagation(); removeSavedPeer('${peer.peerId}')">×</button>
            </div>
            <div class="saved-peer-stats">
              <div class="saved-stat-item">
                <span class="saved-stat-icon">🎁</span>
                <span class="saved-stat-label">Reward</span>
                <span class="saved-stat-value">${peer.reward.toLocaleString()}</span>
                ${rewardChange !== 0 ? `<span class="change-indicator ${rewardChange > 0 ? 'positive' : 'negative'}">${rewardChange}</span>` : ''}
              </div>
              <div class="saved-stat-item">
                <span class="saved-stat-icon">🏆</span>
                <span class="saved-stat-label">Wins</span>
                <span class="saved-stat-value">${peer.score.toLocaleString()}</span>
                ${scoreChange !== 0 ? `<span class="change-indicator ${scoreChange > 0 ? 'positive' : 'negative'}">${scoreChange}</span>` : ''}
              </div>
            </div>
            <div class="saved-peer-footer">
              <span class="last-updated">Last updated: ${lastUpdated}</span>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    function removeSavedPeer(peerId) {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      delete savedPeers[peerId];
      localStorage.setItem(savedPeersKey, JSON.stringify(savedPeers));
      displaySavedPeers();
    }
    
    // Make removeSavedPeer globally accessible
    window.removeSavedPeer = removeSavedPeer;
    
    // Debug function to check saved peers state
    window.debugSavedPeers = function() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const totalRewards = Object.values(savedPeers).reduce((sum, peer) => sum + peer.reward, 0);
      const totalWins = Object.values(savedPeers).reduce((sum, peer) => sum + peer.score, 0);
      
      console.log('=== Saved Peers Debug ===');
      console.log('Total peers:', Object.keys(savedPeers).length);
      console.log('Total rewards:', totalRewards);
      console.log('Total wins:', totalWins);
      console.log('Peers:', savedPeers);
      console.log('=======================');
      
      return { savedPeers, totalRewards, totalWins };
    };
    
    // Force refresh totals display
    window.forceRefreshTotals = function() {
      displaySavedPeers();
      console.log('Forced refresh of totals display');
    };
    
    // Clear rate limit for saved peers updates
    window.clearSavedPeersRateLimit = function() {
      const rateLimit = localStorage.getItem(rateLimitKey);
      const limits = rateLimit ? JSON.parse(rateLimit) : {};
      delete limits.savedPeersUpdate;
      localStorage.setItem(rateLimitKey, JSON.stringify(limits));
      console.log('Cleared saved peers rate limit');
    };
    
    // Force immediate refresh of saved peers
    window.forceRefreshSavedPeers = function() {
      console.log('Force refreshing saved peers...');
      clearSavedPeersRateLimit();
      updateSavedPeers();
    };
    
    // Clean up invalid peers (those that consistently return 404)
    window.cleanupInvalidPeers = function() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const validPeers = {};
      let removedCount = 0;
      
      for (const [peerId, peer] of Object.entries(savedPeers)) {
        // Keep peers that are online or have recent activity
        if (peer.online !== false || (peer.lastUpdated && Date.now() - peer.lastUpdated < 24 * 60 * 60 * 1000)) {
          validPeers[peerId] = peer;
        } else {
          removedCount++;
          console.log(`Removing invalid peer: ${peer.peerName} (${peerId})`);
        }
      }
      
      localStorage.setItem(savedPeersKey, JSON.stringify(validPeers));
      displaySavedPeers();
      console.log(`Cleaned up ${removedCount} invalid peers`);
      
      return { removedCount, remainingCount: Object.keys(validPeers).length };
    };
    
    // Remove offline peers
    window.removeOfflinePeers = function() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const onlinePeers = {};
      let removedCount = 0;
      
      for (const [peerId, peer] of Object.entries(savedPeers)) {
        if (peer.online !== false) {
          onlinePeers[peerId] = peer;
        } else {
          removedCount++;
          console.log(`Removing offline peer: ${peer.peerName} (${peerId})`);
        }
      }
      
      localStorage.setItem(savedPeersKey, JSON.stringify(onlinePeers));
      displaySavedPeers();
      console.log(`Removed ${removedCount} offline peers`);
      
      return { removedCount, remainingCount: Object.keys(onlinePeers).length };
    };
    
    // Function to refresh saved peers data
    async function refreshSavedPeers() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const updatedPeers = {};
      let totalRewardChange = 0;
      let totalWinChange = 0;
      
      console.log('Starting refresh of saved peers:', Object.keys(savedPeers));
      
      for (const [peerId, peer] of Object.entries(savedPeers)) {
        try {
          console.log(`Refreshing peer: ${peer.peerName} (${peerId})`);
          
          // Fetch latest peer data
          const peerData = await fetchWithCorsProxy(`https://dashboard.gensyn.ai/api/v1/peer?id=${peerId}`);
          
          console.log('=== PEER DATA DEBUG ===');
          console.log('Peer data received:', peerData);
          console.log('Peer data type:', typeof peerData);
          console.log('Peer data keys:', peerData ? Object.keys(peerData) : 'null/undefined');
          console.log('Has peerId?', peerData && peerData.peerId ? 'YES' : 'NO');
          console.log('peerId value:', peerData && peerData.peerId);
          console.log('Raw peerData string:', JSON.stringify(peerData));
          console.log('Validation check:', peerData && peerData.peerId ? 'PASS' : 'FAIL');
          console.log('=== END DEBUG ===');
          
          // Simple test to verify data structure
          if (peerData) {
            console.log('TEST: peerData exists');
            console.log('TEST: peerData.peerId =', peerData.peerId);
            console.log('TEST: peerData.reward =', peerData.reward);
            console.log('TEST: peerData.score =', peerData.score);
          } else {
            console.log('TEST: peerData is null/undefined');
          }
          
          // Try to parse if it's a string
          if (typeof peerData === 'string') {
            try {
              const parsedData = JSON.parse(peerData);
              console.log('Parsed from string:', parsedData);
              if (parsedData && parsedData.peerId) {
                const newReward = parsedData.reward || 0;
                const newScore = parsedData.score || 0;
                // ... rest of the logic
                return;
              }
            } catch (e) {
              console.log('Failed to parse string:', e);
            }
          }
          
          if (peerData && peerData.peerId) {
            const newReward = peerData.reward || 0;
            const newScore = peerData.score || 0;
            
            // Calculate changes
            const rewardChange = newReward - peer.reward;
            const scoreChange = newScore - peer.score;
            
            // Update peer data
            updatedPeers[peerId] = {
              ...peer,
              reward: newReward,
              score: newScore,
              lastUpdated: Date.now(),
              online: true, // Mark as online since we got valid data
              changes: {
                reward: rewardChange,
                score: scoreChange
              }
            };
            
            // Add to total changes
            totalRewardChange += rewardChange;
            totalWinChange += scoreChange;
            
            console.log(`Peer ${peer.peerName}: Reward ${peer.reward} → ${newReward} (${rewardChange > 0 ? '+' : ''}${rewardChange}), Score ${peer.score} → ${newScore} (${scoreChange > 0 ? '+' : ''}${scoreChange})`);
          } else {
            console.log(`No valid peer data received for ${peer.peerName}, marking as offline`);
            console.log('Invalid peer data structure:', peerData);
            // Mark peer as offline if no valid response
            updatedPeers[peerId] = {
              ...peer,
              lastUpdated: Date.now(),
              online: false, // Mark as offline
              changes: {
                reward: 0,
                score: 0
              }
            };
          }
        } catch (error) {
          console.error(`Failed to refresh peer ${peer.peerName}:`, error);
          
          // Check if it's a 404 error (peer not found)
          const is404Error = error.message && error.message.includes('404');
          
          if (is404Error) {
            console.log(`Peer ${peer.peerName} not found (404), marking as offline`);
            updatedPeers[peerId] = {
              ...peer,
              lastUpdated: Date.now(),
              online: false, // Mark as offline
              changes: {
                reward: 0,
                score: 0
              }
            };
          } else {
            // Keep existing data for other types of errors
            updatedPeers[peerId] = {
              ...peer,
              lastUpdated: Date.now(),
              changes: {
                reward: 0,
                score: 0
              }
            };
          }
        }
      }
      
      console.log('Updated peers:', Object.keys(updatedPeers));
      
      // Safety check: ensure we have the same number of peers
      if (Object.keys(updatedPeers).length !== Object.keys(savedPeers).length) {
        console.error('WARNING: Peer count mismatch! Keeping original data.');
        console.log('Original peers:', Object.keys(savedPeers));
        console.log('Updated peers:', Object.keys(updatedPeers));
        return { totalRewardChange: 0, totalWinChange: 0 };
      }
      
      // Save updated peers
      localStorage.setItem(savedPeersKey, JSON.stringify(updatedPeers));
      
      // Update display
      displaySavedPeers();
      
      // Update slider with saved peers data
      displaySavedPeersSlider();
      
      // Show total changes in summary if any
      if (totalRewardChange !== 0 || totalWinChange !== 0) {
        showTotalChanges(totalRewardChange, totalWinChange);
      }
      
      // Clear changes after 5 seconds
      setTimeout(() => {
        clearPeerChanges();
      }, 5000);
      
      return { totalRewardChange, totalWinChange };
    }
    
    // Function to show total changes with animation
    function showTotalChanges(rewardChange, winChange) {
      const rewardsElement = document.getElementById('total-rewards');
      const winsElement = document.getElementById('total-wins');
      
      if (rewardChange > 0) {
        rewardsElement.style.animation = 'pulse 0.5s ease-in-out';
        rewardsElement.style.color = '#00ff88';
        setTimeout(() => {
          rewardsElement.style.color = 'var(--primary-color)';
          rewardsElement.style.animation = '';
        }, 1000);
      }
      
      if (winChange > 0) {
        winsElement.style.animation = 'pulse 0.5s ease-in-out';
        winsElement.style.color = '#00ff88';
        setTimeout(() => {
          winsElement.style.color = 'var(--primary-color)';
          winsElement.style.animation = '';
        }, 1000);
      }
    }
    
    // Function to clear peer changes
    function clearPeerChanges() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      let hasChanges = false;
      
      for (const [peerId, peer] of Object.entries(savedPeers)) {
        if (peer.changes && (peer.changes.reward !== 0 || peer.changes.score !== 0)) {
          savedPeers[peerId] = {
            ...peer,
            changes: {
              reward: 0,
              score: 0
            }
          };
          hasChanges = true;
        }
      }
      
      if (hasChanges) {
        localStorage.setItem(savedPeersKey, JSON.stringify(savedPeers));
        displaySavedPeers();
        displaySavedPeersSlider();
        console.log('Cleared peer changes');
      }
    }
    
    // Function to show saved peer details
    function showSavedPeerDetails(peerId) {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const peer = savedPeers[peerId];
      
      if (!peer) return;
      
      // Create modal or update search results
      const detailDiv = document.getElementById('peer-detail');
      detailDiv.style.display = 'block';
      
      detailDiv.innerHTML = `
        <div class="peer-card">
          <div class="peer-header">
            <div class="peer-avatar">${peer.peerName.charAt(0).toUpperCase()}</div>
            <div class="peer-info">
              <h3 class="peer-name">${peer.peerName}</h3>
              <span class="peer-status ${peer.online ? 'online' : 'offline'}">${peer.online ? '🟢 Online' : '🔴 Offline'}</span>
            </div>
          </div>
          <div class="peer-stats">
            <div class="stat-item-cool">
              <span class="stat-icon">🎁</span>
              <span class="stat-label-cool">Reward</span>
              <span class="stat-value-cool">${peer.reward.toLocaleString()}</span>
            </div>
            <div class="stat-item-cool">
              <span class="stat-icon">🏆</span>
              <span class="stat-label-cool">Wins</span>
              <span class="stat-value-cool">${peer.score.toLocaleString()}</span>
            </div>
          </div>
          <div class="peer-details">
            <div class="detail-item">
              <span class="detail-label">Peer ID</span>
              <span class="detail-value">${peer.peerId}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">EOA Address</span>
              <span class="detail-value">${peer.eoa || 'Not available'}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Last Updated</span>
              <span class="detail-value">${new Date(peer.lastUpdated).toLocaleString()}</span>
            </div>
            ${peer.changes.reward !== 0 ? `
            <div class="detail-item">
              <span class="detail-label">Reward Change</span>
              <span class="detail-value ${peer.changes.reward > 0 ? 'positive' : 'negative'}">${peer.changes.reward > 0 ? '+' : ''}${peer.changes.reward}</span>
            </div>
            ` : ''}
            ${peer.changes.score !== 0 ? `
            <div class="detail-item">
              <span class="detail-label">Score Change</span>
              <span class="detail-value ${peer.changes.score > 0 ? 'positive' : 'negative'}">${peer.changes.score > 0 ? '+' : ''}${peer.changes.score}</span>
            </div>
            ` : ''}
          </div>
          <div class="peer-footer">
            <span class="success-badge">✓ Saved Peer Details</span>
          </div>
        </div>
      `;
      
      // Scroll to the details
      detailDiv.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Make showSavedPeerDetails globally accessible
    window.showSavedPeerDetails = showSavedPeerDetails;
    
    // Update saved peers with rate limiting (every 15 minutes)
    async function updateSavedPeers() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const peerIds = Object.keys(savedPeers);
      
      if (peerIds.length === 0) return;
      
      // Check rate limit for saved peers updates
      if (isRateLimited('savedPeersUpdate')) {
        console.log('Saved peers update rate limited');
        return;
      }
      
      console.log(`Updating ${peerIds.length} saved peers...`);
      
      const updatedPeers = {};
      let totalRewardChange = 0;
      let totalWinChange = 0;
      
      for (const peerId of peerIds) {
        try {
          const peerData = await fetchWithCorsProxy(`https://dashboard.gensyn.ai/api/v1/peer?id=${peerId}`);
          
          if (peerData && peerData.peerId) {
            const peer = savedPeers[peerId];
            const newReward = peerData.reward || 0;
            const newScore = peerData.score || 0;
            
            // Calculate changes
            const rewardChange = newReward - peer.reward;
            const scoreChange = newScore - peer.score;
            
            // Update peer data
            updatedPeers[peerId] = {
              ...peer,
              reward: newReward,
              score: newScore,
              lastUpdated: Date.now(),
              online: true, // Mark as online since we got valid data
              changes: {
                reward: rewardChange,
                score: scoreChange
              }
            };
            
            // Add to total changes
            totalRewardChange += rewardChange;
            totalWinChange += scoreChange;
            
            console.log(`Auto-update peer ${peer.peerName}: Reward ${peer.reward} → ${newReward} (${rewardChange > 0 ? '+' : ''}${rewardChange}), Score ${peer.score} → ${newScore} (${scoreChange > 0 ? '+' : ''}${scoreChange})`);
          } else {
            console.log(`No valid peer data received for ${savedPeers[peerId].peerName}, marking as offline`);
            // Mark peer as offline if no valid response
            updatedPeers[peerId] = {
              ...savedPeers[peerId],
              lastUpdated: Date.now(),
              online: false, // Mark as offline
              changes: {
                reward: 0,
                score: 0
              }
            };
          }
        } catch (err) {
          console.error(`Error updating peer ${peerId}:`, err);
          
          // Check if it's a 404 error (peer not found)
          const is404Error = err.message && err.message.includes('404');
          
          if (is404Error) {
            console.log(`Peer ${savedPeers[peerId].peerName} not found (404), marking as offline`);
            updatedPeers[peerId] = {
              ...savedPeers[peerId],
              lastUpdated: Date.now(),
              online: false, // Mark as offline
              changes: {
                reward: 0,
                score: 0
              }
            };
          } else {
            // Keep existing data for other types of errors
            updatedPeers[peerId] = savedPeers[peerId];
          }
        }
        
        // Small delay between requests to be respectful
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      // Save updated peers
      localStorage.setItem(savedPeersKey, JSON.stringify(updatedPeers));
      
      // Update display
      displaySavedPeers();
      
      // Update slider with saved peers data
      displaySavedPeersSlider();
      
      // Show total changes in summary if any
      if (totalRewardChange !== 0 || totalWinChange !== 0) {
        showTotalChanges(totalRewardChange, totalWinChange);
      }
      
      // Clear changes after 5 seconds
      setTimeout(() => {
        clearPeerChanges();
      }, 5000);
      
      // Set rate limit after updating all peers
      setRateLimit('savedPeersUpdate');
      console.log('Saved peers updated successfully');
    }
    
    // Update saved peers every 5 minutes for more frequent updates
    setInterval(updateSavedPeers, 5 * 60 * 1000); // 5 minutes
    
    // Fetch stats on page load
    fetchNetworkStats();
    
    // Display saved peers on page load
    displaySavedPeers();
    
    // Update saved peers data immediately on page load
    updateSavedPeers();
    
    // --- Display saved peers in slider ---
    function displaySavedPeersSlider() {
      const sliderDiv = document.getElementById('rewards-slider');
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      
      sliderDiv.style.display = 'block';
      
      if (Object.keys(savedPeers).length === 0) {
        sliderDiv.innerHTML = '<span class="reward-item">No saved peers yet. Search for peers to track them!</span>';
        return;
      }
      
      // Sort peers by reward (highest first) and take top 10, filter out invalid peers
      const sortedPeers = Object.values(savedPeers)
        .filter(peer => peer && peer.peerName && peer.reward !== undefined)
        .sort((a, b) => b.reward - a.reward)
        .slice(0, 10);
      
      const rewardsHtml = sortedPeers.map(peer => {
        const changeIndicator = peer.changes && peer.changes.reward !== 0 
          ? ` <span style="color: ${peer.changes.reward > 0 ? '#00ff88' : '#ff4757'}; font-weight: bold;">(${peer.changes.reward > 0 ? '+' : ''}${peer.changes.reward})</span>`
          : '';
        
        return `<span class="reward-item">${peer.peerName} - ${peer.reward.toLocaleString()}${changeIndicator}</span>`;
      }).join(' ');
      
      sliderDiv.innerHTML = rewardsHtml;
    }
    
    // Display saved peers slider on page load and update when peers change
    displaySavedPeersSlider();
    
    // Email Modal Functions
    function openEmailModal() {
      document.getElementById('email-modal').style.display = 'block';
    }

    function closeEmailModal() {
      document.getElementById('email-modal').style.display = 'none';
    }

    function savePeersToFile() {
      const fileName = document.getElementById('file-name').value.trim();
      if (!fileName) {
        document.getElementById('email-status').textContent = 'Please enter a file name.';
        document.getElementById('email-status').style.color = 'red';
        return;
      }
      
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      if (Object.keys(savedPeers).length === 0) {
        document.getElementById('email-status').textContent = 'No peers to save!';
        document.getElementById('email-status').style.color = 'orange';
        return;
      }
      
      const peersToSave = Object.values(savedPeers).map(peer => ({
        peerId: peer.peerId,
        peerName: peer.peerName,
        reward: peer.reward,
        score: peer.score,
        online: peer.online,
        lastUpdated: peer.lastUpdated,
        changes: peer.changes
      }));

      try {
        const data = {
          savedPeers: peersToSave,
          savedAt: new Date().toISOString(),
          totalPeers: peersToSave.length
        };
        const jsonData = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${fileName}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        document.getElementById('email-status').textContent = `✅ Saved ${peersToSave.length} peers as ${fileName}.json`;
        document.getElementById('email-status').style.color = 'green';
      } catch (err) {
        document.getElementById('email-status').textContent = `❌ Error saving file: ${err.message}`;
        document.getElementById('email-status').style.color = 'red';
      }
    }

    function loadPeersFromFile() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        try {
          const text = await file.text();
          const loadedData = JSON.parse(text);
          
          // Handle both old format (email/peers) and new format (savedPeers)
          let peers = [];
          if (loadedData.savedPeers) {
            peers = loadedData.savedPeers;
          } else if (loadedData.peers) {
            peers = loadedData.peers;
          } else {
            throw new Error('Invalid file format');
          }

          const existingPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
          let addedCount = 0;
          let updatedCount = 0;

          for (const peer of peers) {
            if (existingPeers[peer.peerId]) {
              // Update existing peer
              const oldData = existingPeers[peer.peerId];
              const rewardChange = peer.reward - oldData.reward;
              const scoreChange = peer.score - oldData.score;
              existingPeers[peer.peerId] = {
                ...peer,
                lastUpdated: new Date().toISOString(),
                previousData: {
                  reward: oldData.reward,
                  score: oldData.score,
                  lastUpdated: oldData.lastUpdated
                },
                changes: {
                  reward: rewardChange,
                  score: scoreChange
                }
              };
              updatedCount++;
            } else {
              // New peer
              existingPeers[peer.peerId] = {
                ...peer,
                lastUpdated: new Date().toISOString(),
                previousData: null,
                changes: {
                  reward: 0,
                  score: 0
                }
              };
              addedCount++;
            }
          }
          
          localStorage.setItem(savedPeersKey, JSON.stringify(existingPeers));
          displaySavedPeers();
          
          let message = '';
          if (addedCount > 0 && updatedCount > 0) {
            message = `✅ Added ${addedCount} new peers and updated ${updatedCount} existing peers`;
          } else if (addedCount > 0) {
            message = `✅ Added ${addedCount} new peers`;
          } else if (updatedCount > 0) {
            message = `✅ Updated ${updatedCount} existing peers`;
          } else {
            message = '✅ File loaded but no changes made';
          }
          
          document.getElementById('email-status').textContent = message;
          document.getElementById('email-status').style.color = 'green';
        } catch (err) {
          document.getElementById('email-status').textContent = `❌ Error loading file: ${err.message}`;
          document.getElementById('email-status').style.color = 'red';
        }
      };
      input.click();
    }

    // Close modal if user clicks outside
    window.onclick = function(event) {
      const emailModal = document.getElementById('email-modal');
      if (event.target == emailModal) {
        closeEmailModal();
      }
    }
    
    // Debug: Check if elements exist
    console.log('Debug: Checking elements...');
    console.log('Top rewards banner:', document.getElementById('top-rewards-banner'));
    console.log('Rewards slider:', document.getElementById('rewards-slider'));
    console.log('Search form:', document.getElementById('search-form'));
    console.log('Saved peers section:', document.getElementById('saved-peers'));
  </script>
</body>
</html>