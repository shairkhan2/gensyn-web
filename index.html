<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gensyn Tracker - Real-time Network Stats</title>
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <style>
    /* Lightweight FX layer (self-contained, minimal) */
    #fx-shapes { position: fixed; inset: 0; pointer-events: none; z-index: 0; overflow: hidden; }
    .fx-shape { position: absolute; width: 10vmin; height: 10vmin; opacity: 0.08; border-radius: 20%; filter: blur(0.5px); }
    .fx-shape.s1 { background: radial-gradient(circle at 30% 30%, #7c3aed, transparent 60%), #7c3aed; }
    .fx-shape.s2 { background: radial-gradient(circle at 70% 70%, #22d3ee, transparent 60%), #22d3ee; }
    .fx-shape.s3 { background: radial-gradient(circle at 50% 50%, #34d399, transparent 60%), #34d399; }
    .fx-shape.s4 { background: radial-gradient(circle at 50% 50%, #f472b6, transparent 60%), #f472b6; }
    header, main, footer, #announcement, #top-rewards-banner { position: relative; z-index: 1; }
    /* Ensure theme toggle is always visible */
    #theme-toggle {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 1001;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      transition: transform 120ms ease, background 160ms ease, border-color 160ms ease;
    }
    #theme-toggle:hover { transform: scale(1.06); background: rgba(0,0,0,0.35); border-color: rgba(255,255,255,0.25); }

    /* Saved peers hover and id/eoa row styles */
    .saved-peers-grid { perspective: 1000px; transform-style: preserve-3d; }
    .saved-peer-card { position: relative; contain: paint; overflow: hidden; cursor: default; transform-origin: center; will-change: transform, box-shadow; transition: transform 160ms ease, box-shadow 160ms ease; 
      --rx: 0deg; --ry: 0deg; --scale: 1; --elev: 0px; 
      transform: translateY(var(--elev)) rotateX(var(--rx)) rotateY(var(--ry)) scale(var(--scale)); }
    .saved-peer-card::before { content: ""; position: absolute; inset: -1px; border-radius: inherit; pointer-events: none; background: radial-gradient(120% 120% at var(--mx, 50%) var(--my, 0%), rgba(99,102,241,0.22), rgba(139,92,246,0.12) 40%, transparent 70%); opacity: 0; transition: opacity 220ms ease; }
    .saved-peer-card:hover { --scale: 1.04; --elev: -2px; box-shadow: 0 10px 26px rgba(0,0,0,0.28); }
    .saved-peer-card:hover::before { opacity: 1; }
    @keyframes fadeSlideIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes statPop { 0% { transform: translateY(4px) scale(0.98); opacity: 0; } 100% { transform: translateY(0) scale(1); opacity: 1; } }
    /* Make expand panel an overlay so card size never changes */
    .saved-peer-expand { position: absolute; left: 10px; right: 10px; bottom: 10px; background: rgba(0,0,0,0.35); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 8px; opacity: 0; transform: translateY(8px) scale(0.98); transition: opacity 160ms ease, transform 200ms ease; will-change: opacity, transform; pointer-events: none; }
    .saved-peer-card:hover .saved-peer-expand { opacity: 1; transform: translateY(0) scale(1); pointer-events: auto; }
    .saved-peer-ids { display: grid; grid-template-columns: 1fr auto; gap: 4px 8px; align-items: center; padding: 6px 8px; border-top: 1px solid rgba(255,255,255,0.08); }
    .saved-peer-ids .id-label { font-size: 11px; opacity: 0.75; }
    .saved-peer-ids .id-value { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 11px; opacity: 0.95; display: inline-block; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .saved-peer-card:hover .saved-peer-ids .row-1 { animation: fadeSlideIn 240ms ease forwards; animation-delay: 40ms; }
    .saved-peer-card:hover .saved-peer-ids .row-2 { animation: fadeSlideIn 260ms ease forwards; animation-delay: 90ms; }
    .saved-peer-card .saved-peer-stats .saved-stat-item { opacity: 0.98; transform: translateY(0) scale(1); transition: transform 180ms ease, opacity 180ms ease; will-change: transform, opacity; }
    .saved-peer-card:hover .saved-peer-stats .saved-stat-item:nth-child(1) { animation: statPop 220ms ease forwards; }
    .saved-peer-card:hover .saved-peer-stats .saved-stat-item:nth-child(2) { animation: statPop 240ms ease forwards; animation-delay: 30ms; }
    .copy-btn { appearance: none; border: 1px solid rgba(255,255,255,0.15); background: transparent; color: inherit; font-size: 10px; padding: 2px 6px; border-radius: 6px; cursor: pointer; transition: background 140ms ease, border-color 140ms ease; will-change: background, border-color; }
    .copy-btn:hover { background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.25); }
    .copy-btn.copied { background: rgba(34,197,94,0.2); border-color: rgba(34,197,94,0.5); }
  </style>
</head>
<body>
  <div id="fx-shapes" aria-hidden="true"></div>
  <header>
    <h1>üèÜ Gensyn Tracker</h1>
    <button id="theme-toggle" aria-label="Toggle dark/light mode">üåô</button>
  </header>
  
  <div id="top-rewards-banner">
    <div id="rewards-slider"></div>
  </div>
      <div id="announcement" class="announcement">
      <div class="announcement-content">
        <div class="owner-info">
          <span class="owner-title">Owner of Site</span>
          <div class="telegram-link">
            <span class="telegram-icon">üì±</span>
            <a href="https://t.me/Shair25" target="_blank" class="owner-name">SHAIR</a>
          </div>
        </div>
      </div>
      <button id="close-announcement" aria-label="Close announcement">&times;</button>
    </div>
    
    <!-- Hero Section -->
    <section id="hero" class="hero">
      <div class="hero-inner">
        <h1 class="hero-title">Gensyn Tracker</h1>
        <form id="hero-search-form" class="hero-search" autocomplete="off">
          <input id="hero-search-input" class="hero-search-input" type="text" placeholder="Search peers by name or ID..." aria-label="Search peers" required />
          <button class="hero-search-btn" type="submit">Search</button>
        </form>
        
      </div>
    </section>

    
    
    <!-- Email Modal -->
    <div id="email-modal" class="email-modal">
      <div class="email-modal-content">
        <div class="email-modal-header">
          <h3>üíæ Save Peers as JSON</h3>
          <button class="close-modal" onclick="closeEmailModal()">&times;</button>
        </div>
        <div class="email-modal-body">
          <p>Save or load your peers:</p>
          <div class="email-input-group">
            <input type="text" id="file-name" placeholder="my-peers" class="email-input">
            <button onclick="savePeersToFile()" class="email-btn save-btn">üíæ Save as JSON</button>
            <button onclick="loadPeersFromFile()" class="email-btn load-btn">üì• Load JSON</button>
          </div>
          <div id="email-status" class="email-status"></div>
        </div>
      </div>
    </div>
    

  <main>
    <section id="stats">
      <div class="stats-header">
        <h2>üåê Network Stats</h2>
        <span class="last-updated" id="stats-last-updated"></span>
      </div>
      <div id="stats-content">
        <p>Loading stats...</p>
      </div>
    </section>
    <section id="saved-peers">
      <div class="saved-peers-header">
        <h2>My Saved Peers</h2>
        <div class="inline-summary" style="position: absolute; left: 50%; transform: translateX(-50%); display: inline-flex !important; flex-direction: row !important; align-items: center !important; justify-content: center !important; gap: 0.5rem; padding: 0.4rem 0.8rem; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2)) !important; border-radius: 15px; border: 1px solid rgba(255, 255, 255, 0.2) !important; backdrop-filter: blur(10px); z-index: 10; min-width: 100px; flex-wrap: nowrap !important; box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3) !important; animation: float 3s ease-in-out infinite; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">
          <span class="summary-icon" style="font-size: 1rem !important; color: var(--primary-color) !important; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important; margin-right: 0.2rem;">üéÅ</span>
          <span class="summary-value" id="total-rewards" style="font-size: 0.9rem !important; font-weight: 700 !important; color: var(--primary-color) !important; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important; min-width: 2rem; text-align: center; margin-right: 0.5rem;">0</span>
          <span class="summary-icon" style="font-size: 1rem !important; color: var(--primary-color) !important; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important; margin-right: 0.2rem;">üèÜ</span>
          <span class="summary-value" id="total-wins" style="font-size: 0.9rem !important; font-weight: 700 !important; color: var(--primary-color) !important; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important; min-width: 2rem; text-align: center; margin-right: 0.5rem;">0</span>
        </div>
        <div class="saved-peers-controls" style="display: flex; flex-direction: row; align-items: center; gap: 0.5rem;">
          <button id="refresh-btn" class="email-sync-btn-small" aria-label="Refresh data" title="Refresh all data">
            <span class="refresh-icon">üîÑ</span>
            <span class="refresh-text">Refresh</span>
          </button>
          <a href="/card" class="email-sync-btn-small" aria-label="Open history" title="Reward/Win change history">üóÇ History</a>
          <button onclick="openEmailModal()" class="email-sync-btn-small">
            üíæ Saved
          </button>
        </div>
      </div>
      <div id="saved-peers-content">
        <p>No saved peers yet. Search for peers to save them!</p>
      </div>
    </section>

    
    <section id="peer-search">
      <h2 style="display:none;">üîç Search Peer</h2>
      <form id="search-form" style="display:none;">
        <div class="search-input-group">
          <input type="text" id="search-input" placeholder="Enter peer name or ID" required>
          <button type="submit">üîç Search</button>
        </div>
        <div class="search-tips">
          <small style="display:none;">üí° Tips: Try peer names or peer IDs (Qm...)</small>
        </div>
      </form>
      <div id="peer-detail" class="peer-detail" style="display:none;"></div>
    </section>
    <section id="leaderboard">
      <div class="leaderboard-header">
        <h2>üèÜ Leaderboard</h2>
        <span class="last-updated" id="leaderboard-last-updated"></span>
      </div>
      <div id="leaderboard-content">
        <p>Loading leaderboard...</p>
      </div>
    </section>
  </main>
  <footer>
    <p>&copy; 2024 Gensyn Tracker - Real-time Network Monitoring</p>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
  <script>
    // Clipboard helper for copy buttons
    async function copyToClipboard(text, el) {
      try {
        if (el && typeof el.blur === 'function') el.blur();
        await navigator.clipboard.writeText(text || '');
        if (el) {
          const original = el.textContent;
          el.textContent = 'Copied';
          el.classList.add('copied');
          setTimeout(() => { el.textContent = 'Copy'; el.classList.remove('copied'); }, 900);
        }
      } catch (e) { console.error('Copy failed', e); }
    }

    // Note: rely on button-level handlers (type="button" + preventDefault + stopPropagation)

    // Reusable contract helper to fetch EOA for a peerId
    async function fetchEoaForPeerId(peerId) {
      try {
        if (!peerId) return null;
        const provider = new ethers.JsonRpcProvider("https://gensyn-testnet.g.alchemy.com/v2/TD5tr7mo4VfXlSaolFlSr3tL70br2M9J");
        const contract = new ethers.Contract(
          "0xFaD7C5e93f28257429569B854151A1B8DCD404c2",
          [
            { "name": "getEoa", "type": "function", "stateMutability": "view", "inputs": [{ "name": "peerIds", "type": "string[]" }], "outputs": [{ "name": "", "type": "address[]" }] }
          ],
          provider
        );
        const addresses = await contract.getEoa([peerId]);
        const eoa = addresses && addresses[0];
        if (!eoa || eoa === '0x0000000000000000000000000000000000000000') return null;
        return eoa;
      } catch (err) {
        console.error('fetchEoaForPeerId error', err);
        return null;
      }
    }

    // Ensure a saved peer has an EOA; if missing, fetch and persist
    const _eoaFetchInFlight = new Set();
    async function ensurePeerEoa(peerId) {
      try {
        const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
        const peer = savedPeers[peerId];
        if (!peer) return;
        const hasEoa = peer.eoa && peer.eoa !== '0x0000000000000000000000000000000000000000';
        if (hasEoa || _eoaFetchInFlight.has(peerId)) return;
        _eoaFetchInFlight.add(peerId);
        const eoa = await fetchEoaForPeerId(peerId);
        if (eoa) {
          savedPeers[peerId] = { ...peer, eoa };
          localStorage.setItem(savedPeersKey, JSON.stringify(savedPeers));
          // Update only this card in-place to avoid full re-render glitches
          const card = document.querySelector(`.saved-peer-card[data-peerid="${peerId}"]`);
          if (card) {
            const eoaSpan = card.querySelector('[data-role="eoa-value"]');
            const eoaBtn = card.querySelector('[data-role="eoa-copy"]');
            if (eoaSpan) {
              const shortEoa = eoa.length > 12 ? `${eoa.slice(0,12)}‚Ä¶` : eoa;
              eoaSpan.textContent = shortEoa;
              eoaSpan.setAttribute('title', eoa);
            }
            if (eoaBtn) {
              eoaBtn.disabled = false;
              eoaBtn.onclick = function(ev){ ev.preventDefault(); ev.stopPropagation(); copyToClipboard(eoa, eoaBtn); return false; };
            }
          }
        }
      } catch (e) {
        console.error('ensurePeerEoa failed', e);
      } finally {
        _eoaFetchInFlight.delete(peerId);
      }
    }
    // CORS Proxy with fallback
    async function fetchWithCorsProxy(url) {
      console.log('Fetching URL:', url);
      
      // First try our own proxy API
      try {
        console.log('Trying our own proxy API');
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        const response = await fetch(`/api/proxy?url=${encodeURIComponent(url)}`, {
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        console.log('Proxy response status:', response.status);
        
        if (response.ok) {
          try {
            const data = await response.json();
                              console.log('Success with our own proxy API');
                  console.log('Response data:', data);
                  console.log('Response data type:', typeof data);
                  console.log('Response data keys:', data ? Object.keys(data) : 'null/undefined');
                  console.log('Raw response text:', JSON.stringify(data));
                  console.log('=== PROXY DEBUG END ===');
                  console.log('SIMPLE TEST: data.peerId =', data && data.peerId);
                  console.log('SIMPLE TEST: data.reward =', data && data.reward);
                  
                  // Data validation successful
                  console.log('Data validation: SUCCESS');
                  
                  return data;
          } catch (jsonError) {
            console.error('Failed to parse JSON from proxy:', jsonError);
            const text = await response.text();
            console.error('Raw response text:', text.substring(0, 200));
            throw new Error('Invalid JSON response from proxy');
          }
        } else {
          console.log('Proxy response not ok:', response.status, response.statusText);
        }
      } catch (error) {
        console.log('Failed with our own proxy API:', error.message);
      }
      
      // Fallback to external proxies if our proxy fails
      const proxies = [
        'https://cors.bridged.cc/',
        'https://api.allorigins.win/raw?url=',
        'https://thingproxy.freeboard.io/fetch/'
      ];
      
      for (const proxy of proxies) {
        try {
          console.log(`Trying external proxy: ${proxy}`);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
          
          const response = await fetch(proxy + url, {
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            },
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          console.log(`External proxy response status:`, response.status);
          
          if (response.ok) {
            const data = await response.json();
            console.log(`Success with external proxy: ${proxy}`);
            return data;
          } else {
            console.log(`External proxy failed with status:`, response.status);
          }
        } catch (error) {
          console.log(`Failed with external proxy ${proxy}:`, error.message);
          continue;
        }
      }
      
      // If all proxies fail, try direct fetch as last resort
      try {
        console.log('Trying direct fetch as last resort...');
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('Success with direct fetch');
          return data;
        }
      } catch (directError) {
        console.log('Direct fetch also failed:', directError.message);
      }
      
      throw new Error('All proxies and direct fetch failed');
    }

    // Set default theme to dark
    document.body.classList.add('dark-mode');
    
    // Debug version
    console.log('=== DEBUG VERSION 1.4 - ISSUE RESOLVED ===');
    
    // Dark/Light mode toggle
    const themeToggle = document.getElementById('theme-toggle');
    themeToggle.textContent = '‚òÄÔ∏è'; // Start with sun icon since dark mode is default
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      themeToggle.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
    });
    // Announcement close
    document.getElementById('close-announcement').onclick = function() {
      document.getElementById('announcement').style.display = 'none';
    };

    // Refresh functionality
    document.getElementById('refresh-btn').addEventListener('click', async function() {
      console.log('Manual refresh triggered');
      
      const refreshBtn = document.getElementById('refresh-btn');
      const refreshIcon = refreshBtn.querySelector('.refresh-icon');
      const refreshText = refreshBtn.querySelector('.refresh-text');
      
      // Start loading animation
      refreshBtn.disabled = true;
      refreshIcon.textContent = 'üîÑ';
      refreshText.textContent = 'Loading...';
      refreshBtn.style.background = 'linear-gradient(135deg, #ff6b6b, #ffa500)';
      refreshBtn.style.transform = 'scale(0.95)';
      
      // Add a small delay to show the animation
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Clear rate limits to force fresh data
      localStorage.removeItem('rateLimit_networkStats');
      localStorage.removeItem('rateLimit_leaderboard');
      
      try {
        // Refresh all data
        await Promise.all([
          fetchNetworkStats(),
          fetchLeaderboard()
        ]);
        
        // Refresh saved peers data
        await refreshSavedPeers();
        
        // Show success state with Gen Z style
        refreshBtn.style.transform = 'scale(1.05)';
        refreshIcon.textContent = 'üî•';
        refreshText.textContent = 'Lit!';
        refreshBtn.style.background = 'linear-gradient(135deg, #00ff88, #00d4aa)';
        
        setTimeout(() => {
          refreshIcon.textContent = 'üîÑ';
          refreshText.textContent = 'Refresh';
          refreshBtn.style.background = 'linear-gradient(135deg, var(--primary-color), var(--secondary-color))';
          refreshBtn.style.transform = 'scale(1)';
          refreshBtn.disabled = false;
        }, 1500);
        
      } catch (error) {
        console.error('Refresh failed:', error);
        
        // Show error state
        refreshBtn.style.transform = 'scale(0.95)';
        refreshIcon.textContent = 'üíÄ';
        refreshText.textContent = 'Oops!';
        refreshBtn.style.background = 'linear-gradient(135deg, #ff4757, #ff3838)';
        
        setTimeout(() => {
          refreshIcon.textContent = 'üîÑ';
          refreshText.textContent = 'Refresh';
          refreshBtn.style.background = 'linear-gradient(135deg, var(--primary-color), var(--secondary-color))';
          refreshBtn.style.transform = 'scale(1)';
          refreshBtn.disabled = false;
        }, 2000);
      }
    });

    // Peer search functionality
    document.getElementById('search-form').addEventListener('submit', async function(e) {
      e.preventDefault();
      const query = document.getElementById('search-input').value.trim();
      if (!query) return;
      let peerData = null;
      let peerId = null;
      let eoa = null;
      let isEoa = false;
      const detailDiv = document.getElementById('peer-detail');
      detailDiv.style.display = 'block';
      detailDiv.textContent = 'Loading...';
      // Helper: fetch EOA from contract
      async function fetchEoaForPeer(peerId) {
        try {
          console.log('Fetching EOA for peerId:', peerId);
          const provider = new ethers.JsonRpcProvider("https://gensyn-testnet.g.alchemy.com/v2/TD5tr7mo4VfXlSaolFlSr3tL70br2M9J");
          const contract = new ethers.Contract(
            "0xFaD7C5e93f28257429569B854151A1B8DCD404c2",
            [
              {
                "name": "getEoa",
                "type": "function",
                "stateMutability": "view",
                "inputs": [{ "name": "peerIds", "type": "string[]" }],
                "outputs": [{ "name": "", "type": "address[]" }]
              }
            ],
            provider
          );
          const addresses = await contract.getEoa([peerId]);
          console.log('Contract response:', addresses);
          const eoa = addresses[0];
          console.log('EOA address:', eoa);
          return eoa;
        } catch (error) {
          console.error('Error fetching EOA from contract:', error);
          return null;
        }
      }
      // If input looks like an EOA address
      if (query.startsWith('0x') && query.length === 42) {
        isEoa = true;
        eoa = query;
        
        try {
                  // Search for peer info for this EOA address in the leaderboard
        console.log("Searching leaderboard for EOA address");
        const data = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/leaderboard');
        const entries = data.entries || [];
        const matchingPeer = entries.find(peer => peer.eoa && peer.eoa.toLowerCase() === eoa.toLowerCase());
        
        if (matchingPeer && matchingPeer.peerName) {
          // Found peer info for this EOA
          detailDiv.innerHTML = `
            <div class="peer-card">
              <div class="peer-header">
                <div class="peer-avatar">${matchingPeer.peerName.charAt(0).toUpperCase()}</div>
                <div class="peer-info">
                  <h3 class="peer-name">${matchingPeer.peerName}</h3>
                  <span class="peer-status ${matchingPeer.online ? 'online' : 'offline'}">${matchingPeer.online ? 'üü¢ Online' : 'üî¥ Offline'}</span>
                </div>
              </div>
              <div class="peer-stats">
                <div class="stat-item-cool">
                  <span class="stat-icon">üèÜ</span>
                  <span class="stat-label-cool">Reward</span>
                  <span class="stat-value-cool">${matchingPeer.reward.toLocaleString()}</span>
                </div>
                <div class="stat-item-cool">
                  <span class="stat-icon">üìä</span>
                  <span class="stat-label-cool">Score</span>
                  <span class="stat-value-cool">${matchingPeer.score.toLocaleString()}</span>
                </div>
              </div>
              <div class="peer-details">
                <div class="detail-item">
                  <span class="detail-label">Peer ID</span>
                  <span class="detail-value">${matchingPeer.peerId}</span>
                </div>
                <div class="detail-item">
                  <span class="detail-label">EOA Address</span>
                  <span class="detail-value">${eoa}</span>
                </div>
              </div>
              <div class="peer-footer">
                <span class="success-badge">‚úì Found via leaderboard search</span>
              </div>
            </div>
          `;
        } else {
          detailDiv.innerHTML = `
            <div class="peer-card">
              <strong>EOA Address:</strong> ${eoa}<br>
              <span style='color:orange'>‚ö† No peer information found for this EOA address</span><br>
              <span style='color:gray'>This EOA address is not associated with any peer in the current data.</span>
            </div>
          `;
        }
        } catch (err) {
          detailDiv.innerHTML = `
            <div class="peer-card">
              <strong>EOA Address:</strong> ${eoa}<br>
              <span style='color:red'>Error fetching peer information: ${err.message}</span>
            </div>
          `;
        }
        return;
      }
      try {
        // If input looks like a peerId
        if (query.startsWith('Qm')) {
          // Fetch peer info from dashboard API
          peerData = await fetchWithCorsProxy(`https://dashboard.gensyn.ai/api/v1/peer?id=${encodeURIComponent(query)}`);
          peerId = peerData.peerId;
        } else {
          // Assume it's a peer name, fetch info
          peerData = await fetchWithCorsProxy(`https://dashboard.gensyn.ai/api/v1/peer?name=${encodeURIComponent(query)}`);
          peerId = peerData.peerId;
        }
        // Now fetch EOA from contract
        eoa = await fetchEoaForPeer(peerId);
        
        // If contract call failed, try to find EOA in leaderboard data
        if (!eoa || eoa === '0x0000000000000000000000000000000000000000') {
          console.log('Contract call failed or returned zero address, trying leaderboard search...');
          try {
            const leaderboardData = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/leaderboard');
            const entries = leaderboardData.entries || [];
            const matchingPeer = entries.find(peer => peer.peerId === peerId);
            if (matchingPeer && matchingPeer.eoa) {
              eoa = matchingPeer.eoa;
              console.log('Found EOA in leaderboard:', eoa);
            }
          } catch (err) {
            console.error('Error searching leaderboard for EOA:', err);
          }
        }
        
        // Add EOA to peerData before saving
        peerData.eoa = eoa;
        
        // Save peer data automatically
        savePeerData(peerData);
        
        // Validate peer data before displaying
        if (!peerData || !peerData.peerName) {
          throw new Error('Invalid peer data received');
        }
        
        detailDiv.innerHTML = `
          <div class="peer-card">
            <div class="peer-header">
              <div class="peer-avatar">${peerData.peerName.charAt(0).toUpperCase()}</div>
              <div class="peer-info">
                <h3 class="peer-name">${peerData.peerName}</h3>
                <span class="peer-status ${peerData.online ? 'online' : 'offline'}">${peerData.online ? 'üü¢ Online' : 'üî¥ Offline'}</span>
              </div>
            </div>
            <div class="peer-stats">
              <div class="stat-item-cool">
                <span class="stat-icon">üèÜ</span>
                <span class="stat-label-cool">Reward</span>
                <span class="stat-value-cool">${peerData.reward.toLocaleString()}</span>
              </div>
              <div class="stat-item-cool">
                <span class="stat-icon">üìä</span>
                <span class="stat-label-cool">Score</span>
                <span class="stat-value-cool">${peerData.score.toLocaleString()}</span>
              </div>
            </div>
            <div class="peer-details">
              <div class="detail-item">
                <span class="detail-label">Peer ID</span>
                <span class="detail-value">${peerData.peerId}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">EOA Address</span>
                <span class="detail-value">${eoa || 'Not available'}</span>
              </div>
            </div>
            <div class="peer-footer">
              <span class="success-badge">‚úì Found via smart contract & Saved!</span>
            </div>
          </div>
        `;
      } catch (err) {
        console.error('Search error:', err);
        detailDiv.innerHTML = `
          <div class="peer-card">
            <div class="peer-header">
              <div class="peer-avatar">‚ùå</div>
              <div class="peer-info">
                <h3 class="peer-name">Search Failed</h3>
                <span class="peer-status offline">üî¥ Error</span>
              </div>
            </div>
            <div class="peer-details">
              <div class="detail-item">
                <span class="detail-label">Search Query</span>
                <span class="detail-value">${query}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">Error</span>
                <span class="detail-value" style="color: #ff6b6b;">${err.message}</span>
              </div>
            </div>
            <div class="peer-footer">
              <span style="color: #ffa500;">‚ö†Ô∏è Try searching with a valid peer name or ID</span>
            </div>
          </div>
        `;
      }
    });

    // Move leaderboard to a sidebar on the right and show only top 10 peers with name, reward, and score
    // Update HTML structure
    const main = document.querySelector('main');
    if (!document.getElementById('main-content')) {
      const mainContent = document.createElement('div');
      mainContent.id = 'main-content';
      mainContent.style.display = 'flex';
      mainContent.style.gap = '2rem';
      mainContent.innerHTML = `
        <div id="main-sections" style="flex:1; min-width:0;"></div>
        <aside id="leaderboard-aside" style="width:260px; min-width:180px;"></aside>
      `;
      // Move all sections except leaderboard into main-sections
      const stats = document.getElementById('stats');
      const savedPeers = document.getElementById('saved-peers');
      const peerSearch = document.getElementById('peer-search');
      mainContent.querySelector('#main-sections').appendChild(savedPeers);
      mainContent.querySelector('#main-sections').appendChild(peerSearch);
      
      // Move stats to leaderboard aside and make it small
      const statsSection = document.getElementById('stats');
      statsSection.style.marginBottom = '1rem';
      mainContent.querySelector('#leaderboard-aside').insertBefore(statsSection, mainContent.querySelector('#leaderboard-aside').firstChild);
      // Move leaderboard section into aside
      const leaderboard = document.getElementById('leaderboard');
      mainContent.querySelector('#leaderboard-aside').appendChild(leaderboard);
      main.innerHTML = '';
      main.appendChild(mainContent);
    }
    // Leaderboard fetch and click-to-detail (Gensyn style) with caching and rate limiting
    async function fetchLeaderboard() {
      const leaderboardDiv = document.getElementById('leaderboard-content');
      console.log('Fetching leaderboard...');
      
      // Try to get cached data first
      const cachedData = getCachedData('leaderboard');
      console.log('Cached data:', cachedData ? 'Found' : 'Not found');
      
      if (cachedData) {
        console.log('Displaying cached leaderboard data');
        displayLeaderboard(cachedData);
      }
      
      // Check rate limit for leaderboard (15 min interval)
      if (isRateLimited('leaderboard') && cachedData) {
        console.log('Leaderboard rate limited, using cached data');
        return;
      }
      
      // Only show loading if no cached data
      if (!cachedData) {
        leaderboardDiv.innerHTML = 'Loading leaderboard...';
      }
      
      try {
        console.log('Fetching leaderboard with fallback proxies...');
        const data = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/leaderboard');
        console.log('Leaderboard data received:', data);
        
        // Cache the new data and set rate limit
        setCachedData('leaderboard', data);
        setRateLimit('leaderboard');
        
        // Update last updated time
        const now = new Date();
        document.getElementById('leaderboard-last-updated').textContent = `Last updated: ${now.toLocaleTimeString()}`;
        
        displayLeaderboard(data);
      } catch (err) {
        console.error('Leaderboard fetch error:', err);
        // Only show error if no cached data available
        if (!cachedData) {
          leaderboardDiv.innerHTML = '<span style="color:red">Error loading leaderboard.</span>';
        }
      }
    }
    
    function displayLeaderboard(data) {
      const leaderboardDiv = document.getElementById('leaderboard-content');
      const entries = (data.entries || []).slice(0, 10);
      
      if (!Array.isArray(entries) || entries.length === 0) {
        leaderboardDiv.innerHTML = '<span style="color:red">No leaderboard data found.</span>';
        return;
      }
      
              let table = `<div class='gensyn-leaderboard-title'>Top 10 (Gensyn Leaderboard)</div>`;
        table += `<table class='gensyn-leaderboard-table'><thead><tr><th>Rank</th><th>Peer ID</th><th>Wins</th><th>Rewards</th></tr></thead><tbody>`;
      entries.forEach((peer, idx) => {
        let rank, delta;
        if (idx === 0) { rank = 'ü•á'; delta = '‚ñ≤1'; }
        else if (idx === 1) { rank = 'ü•à'; delta = '‚ñº1'; }
        else if (idx === 2) { rank = 'ü•â'; delta = '‚ñ≤1'; }
        else { rank = `#${idx + 1}`; delta = '‚Äì'; }
        // Shorten peerId for display
        const shortPeerId = peer.peerId.slice(0, 8);
        table += `<tr class='gensyn-leaderboard-row' data-peerid="${peer.peerId}">
          <td>${rank}</td>
          <td class='gensyn-peerid'>${shortPeerId}</td>
          <td>${peer.score.toLocaleString()}</td>
          <td>${peer.reward.toLocaleString()}</td>
        </tr>`;
      });
      table += '</tbody></table>';
      leaderboardDiv.innerHTML = table;
      
      // Add click listeners to rows
      document.querySelectorAll('.gensyn-leaderboard-row').forEach(row => {
        row.addEventListener('click', async function() {
          const peerId = this.getAttribute('data-peerid');
          document.getElementById('search-input').value = peerId;
          document.getElementById('search-form').dispatchEvent(new Event('submit'));
          window.scrollTo({ top: document.getElementById('peer-search').offsetTop - 20, behavior: 'smooth' });
        });
      });
    }
    
    // Data caching system with rate limiting
    const cacheKey = 'gensyn_cache_data';
    const cacheExpiry = 5 * 60 * 1000; // 5 minutes
    const rateLimitKey = 'gensyn_rate_limit';
    const rateLimitInterval = 15 * 60 * 1000; // 15 minutes for saved peers updates
    
    function getCachedData(key) {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const data = JSON.parse(cached);
        if (data[key] && Date.now() - data[key].timestamp < cacheExpiry) {
          return data[key].value;
        }
      }
      return null;
    }
    
    function setCachedData(key, value) {
      const cached = localStorage.getItem(cacheKey);
      const data = cached ? JSON.parse(cached) : {};
      data[key] = {
        value: value,
        timestamp: Date.now()
      };
      localStorage.setItem(cacheKey, JSON.stringify(data));
    }
    
    // Rate limiting functions
    function isRateLimited(key) {
      const rateLimit = localStorage.getItem(rateLimitKey);
      if (rateLimit) {
        const limits = JSON.parse(rateLimit);
        const lastCall = limits[key] || 0;
        const now = Date.now();
        return (now - lastCall) < rateLimitInterval;
      }
      return false;
    }
    
    function setRateLimit(key) {
      const rateLimit = localStorage.getItem(rateLimitKey);
      const limits = rateLimit ? JSON.parse(rateLimit) : {};
      limits[key] = Date.now();
      localStorage.setItem(rateLimitKey, JSON.stringify(limits));
    }
    
    // Fetch leaderboard on page load
    fetchLeaderboard();
    
    // --- Fix for network stats property and debugging ---
    async function fetchNetworkStats() {
      const statsDiv = document.getElementById('stats-content');
      // Try to get cached data first
      const cachedData = getCachedData('networkStats');
      const cachedRoundData = getCachedData('roundData');
      
        if (cachedData && cachedRoundData) {
        const value = cachedData.connected !== undefined ? cachedData.connected : cachedData.count;
        statsDiv.innerHTML = `
          <div class="stats-card">
            <div class="stat-item">
              <span class="stat-label">Nodes Connected</span>
              <span class="stat-value">${value ? value.toLocaleString() : '?'}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Current Round</span>
              <span class="stat-value">${cachedRoundData.round}</span>
            </div>
          </div>
        `;
          // hero metrics removed
      }
      
      // Check rate limit for network stats (15 min interval)
      if (isRateLimited('networkStats') && cachedData && cachedRoundData) {
        console.log('Network stats rate limited, using cached data');
        return;
      }
      
        try {
        // Fetch nodes connected
        const nodesData = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/nodes-connected');
        const value = nodesData.connected !== undefined ? nodesData.connected : nodesData.count;
        
        // Fetch round data
        const roundData = await fetchWithCorsProxy('https://dashboard.gensyn.ai/api/v1/round-stage');
        
        // Cache both data sets
        setCachedData('networkStats', nodesData);
        setCachedData('roundData', roundData);
        setRateLimit('networkStats');
        
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        
        statsDiv.innerHTML = `
          <div class="stats-card">
            <div class="stat-item">
              <span class="stat-label">üü¢ Nodes Connected</span>
              <span class="stat-value">${value ? value.toLocaleString() : '?'}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">üèÜ Current Round</span>
              <span class="stat-value">${roundData.round}</span>
            </div>
          </div>
        `;
          // hero metrics removed
        
        // Update last updated time
        document.getElementById('stats-last-updated').textContent = `Last updated: ${timeString}`;
      } catch (err) {
        if (!cachedData) {
          statsDiv.innerHTML = '<span style="color:red">Error loading network stats.</span>';
        }
        console.error('Network stats error:', err);
      }
    }
    
    // Peer data management
    const savedPeersKey = 'gensyn_saved_peers';
    const changesHistoryKey = 'gensyn_changes_history';

    function _loadHistory() {
      try { return JSON.parse(localStorage.getItem(changesHistoryKey) || '[]'); } catch (e) { return []; }
    }

    function _saveHistory(entries) {
      try { localStorage.setItem(changesHistoryKey, JSON.stringify(entries)); } catch (e) {}
    }

    function addHistoryEntry(entry) {
      try {
        if (!entry) return;
        const hasDelta = (Number(entry.rewardDelta||0) !== 0) || (Number(entry.winDelta||0) !== 0);
        if (!hasDelta) return;
        const list = _loadHistory();
        list.push({ ...entry, timestamp: Date.now() });
        _saveHistory(list.slice(-2000)); // cap to last 2000 entries
      } catch (e) { /* noop */ }
    }
    
    function savePeerData(peerData) {
      // Validate peer data before saving
      if (!peerData || !peerData.peerId || !peerData.peerName) {
        console.error('Invalid peer data:', peerData);
        return;
      }
      
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const now = new Date().toISOString();
      
      if (savedPeers[peerData.peerId]) {
        // Update existing peer with new data
        const oldData = savedPeers[peerData.peerId];
        const rewardChange = peerData.reward - oldData.reward;
        const scoreChange = peerData.score - oldData.score;
        if (rewardChange !== 0 || scoreChange !== 0) {
          addHistoryEntry({
            peerId: peerData.peerId,
            peerName: peerData.peerName,
            eoa: peerData.eoa,
            rewardDelta: rewardChange,
            winDelta: scoreChange,
            rewardAfter: peerData.reward,
            scoreAfter: peerData.score
          });
        }
        
        savedPeers[peerData.peerId] = {
          ...peerData,
          lastUpdated: now,
          previousData: {
            reward: oldData.reward,
            score: oldData.score,
            lastUpdated: oldData.lastUpdated
          },
          changes: {
            reward: rewardChange,
            score: scoreChange
          }
        };
      } else {
        // New peer
        savedPeers[peerData.peerId] = {
          ...peerData,
          lastUpdated: now,
          previousData: null,
          changes: {
            reward: 0,
            score: 0
          }
        };
      }
      
      localStorage.setItem(savedPeersKey, JSON.stringify(savedPeers));
      displaySavedPeers();
    }
    
    function displaySavedPeers() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const container = document.getElementById('saved-peers-content');
      
      if (Object.keys(savedPeers).length === 0) {
        container.innerHTML = '<p>No saved peers yet. Search for peers to save them!</p>';
        // Clear totals when no peers
        document.getElementById('total-rewards').textContent = '0';
        document.getElementById('total-wins').textContent = '0';
        return;
      }
      
      // Calculate summary stats with error handling
      const totalRewards = Object.values(savedPeers).reduce((sum, peer) => {
        if (peer && typeof peer.reward === 'number') {
          return sum + peer.reward;
        }
        return sum;
      }, 0);
      
      const totalWins = Object.values(savedPeers).reduce((sum, peer) => {
        if (peer && typeof peer.score === 'number') {
          return sum + peer.score;
        }
        return sum;
      }, 0);
      
      // Update header summary
      const rewardsElement = document.getElementById('total-rewards');
      const winsElement = document.getElementById('total-wins');
      
      if (rewardsElement) {
        rewardsElement.textContent = totalRewards.toLocaleString();
      }
      
      if (winsElement) {
        winsElement.textContent = totalWins.toLocaleString();
      }
      
      console.log(`Updated totals: Rewards=${totalRewards}, Wins=${totalWins}`);
      
      const peerCount = Object.keys(savedPeers).length;
      let html = `<div class="saved-peers-grid" data-peer-count="${peerCount}">`;
      
      Object.values(savedPeers).forEach(peer => {
        // Skip invalid peers
        if (!peer || !peer.peerName || !peer.peerId) {
          console.error('Invalid peer data found:', peer);
          return;
        }
        
        const lastUpdated = new Date(peer.lastUpdated).toLocaleString();
        const rewardChange = peer.changes?.reward || 0;
        const scoreChange = peer.changes?.score || 0;
        
        const shortPeerId = peer.peerId.length > 10 ? `${peer.peerId.slice(0, 10)}‚Ä¶` : peer.peerId;
        const hasEoa = peer.eoa && peer.eoa !== '0x0000000000000000000000000000000000000000';
        const shortEoa = hasEoa ? (peer.eoa.length > 10 ? `${peer.eoa.slice(0, 10)}‚Ä¶` : peer.eoa) : 'Fetching‚Ä¶';

        html += `
          <div class="saved-peer-card" data-peerid="${peer.peerId}">
            <div class="saved-peer-header">
              <div class="saved-peer-avatar">${peer.peerName.charAt(0).toUpperCase()}</div>
              <div class="saved-peer-info">
                <h4 class="saved-peer-name">${peer.peerName}</h4>
                <span class="saved-peer-status ${peer.online ? 'online' : 'offline'}">${peer.online ? 'üü¢ Online' : 'üî¥ Offline'}</span>
              </div>
              <button type="button" class="remove-peer-btn" onclick="event.preventDefault(); event.stopPropagation(); event.stopImmediatePropagation(); removeSavedPeer('${peer.peerId}'); return false;">√ó</button>
            </div>
            <div class="saved-peer-stats">
              <div class="saved-stat-item">
                <span class="saved-stat-icon">üéÅ</span>
                <span class="saved-stat-label">Reward</span>
                <span class="saved-stat-value">${peer.reward.toLocaleString()}</span>
                ${rewardChange !== 0 ? `<span class="change-indicator ${rewardChange > 0 ? 'positive' : 'negative'}">${rewardChange}</span>` : ''}
              </div>
              <div class="saved-stat-item">
                <span class="saved-stat-icon">üèÜ</span>
                <span class="saved-stat-label">Wins</span>
                <span class="saved-stat-value">${peer.score.toLocaleString()}</span>
                ${scoreChange !== 0 ? `<span class="change-indicator ${scoreChange > 0 ? 'positive' : 'negative'}">${scoreChange}</span>` : ''}
              </div>
            </div>
            <div class="saved-peer-expand">
              <div class="saved-peer-ids">
                <div class="id-label row-1">Peer ID</div>
                <div class="row-1" style="display:flex; gap:8px; align-items:center; justify-content:flex-end;">
                  <span class="id-value" title="${peer.peerId}">${shortPeerId}</span>
                  <button type="button" class="copy-btn" onclick="(function(e,el){ e.preventDefault(); e.stopPropagation(); copyToClipboard('${peer.peerId}', el); })(event, this); return false;">Copy</button>
                </div>
                <div class="id-label row-2">EOA</div>
                <div class="row-2" style="display:flex; gap:8px; align-items:center; justify-content:flex-end;">
                  <span class="id-value" data-role="eoa-value" title="${hasEoa ? peer.eoa : ''}">${shortEoa}</span>
                  <button type="button" class="copy-btn" data-role="eoa-copy" ${hasEoa ? '' : 'disabled'} onclick="(function(e,el){ e.preventDefault(); e.stopPropagation(); ${hasEoa ? `copyToClipboard('${peer.eoa}', el);` : ''} })(event, this); return false;">Copy</button>
                </div>
              </div>
              <div class="saved-peer-footer" style="display:none;"></div>
            </div>
          </div>
        `;

        // If EOA is missing, trigger background fetch
        if (!hasEoa) {
          ensurePeerEoa(peer.peerId);
        }
      });
      
      html += '</div>';
      container.innerHTML = html;
      // Also rebuild scroll-driven peers section to reflect latest
      // hero totals removed
    }
    
    function removeSavedPeer(peerId) {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      delete savedPeers[peerId];
      localStorage.setItem(savedPeersKey, JSON.stringify(savedPeers));
      displaySavedPeers();
    }
    
    // Make removeSavedPeer globally accessible
    window.removeSavedPeer = removeSavedPeer;
    
    // Debug function to check saved peers state
    window.debugSavedPeers = function() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const totalRewards = Object.values(savedPeers).reduce((sum, peer) => sum + peer.reward, 0);
      const totalWins = Object.values(savedPeers).reduce((sum, peer) => sum + peer.score, 0);
      
      console.log('=== Saved Peers Debug ===');
      console.log('Total peers:', Object.keys(savedPeers).length);
      console.log('Total rewards:', totalRewards);
      console.log('Total wins:', totalWins);
      console.log('Peers:', savedPeers);
      console.log('=======================');
      
      return { savedPeers, totalRewards, totalWins };
    };
    
    // Force refresh totals display
    window.forceRefreshTotals = function() {
      displaySavedPeers();
      console.log('Forced refresh of totals display');
    };
    
    // Clear rate limit for saved peers updates
    window.clearSavedPeersRateLimit = function() {
      const rateLimit = localStorage.getItem(rateLimitKey);
      const limits = rateLimit ? JSON.parse(rateLimit) : {};
      delete limits.savedPeersUpdate;
      localStorage.setItem(rateLimitKey, JSON.stringify(limits));
      console.log('Cleared saved peers rate limit');
    };
    
    // Force immediate refresh of saved peers
    window.forceRefreshSavedPeers = function() {
      console.log('Force refreshing saved peers...');
      clearSavedPeersRateLimit();
      updateSavedPeers();
    };
    
    // Clean up invalid peers (those that consistently return 404)
    window.cleanupInvalidPeers = function() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const validPeers = {};
      let removedCount = 0;
      
      for (const [peerId, peer] of Object.entries(savedPeers)) {
        // Keep peers that are online or have recent activity
        if (peer.online !== false || (peer.lastUpdated && Date.now() - peer.lastUpdated < 24 * 60 * 60 * 1000)) {
          validPeers[peerId] = peer;
        } else {
          removedCount++;
          console.log(`Removing invalid peer: ${peer.peerName} (${peerId})`);
        }
      }
      
      localStorage.setItem(savedPeersKey, JSON.stringify(validPeers));
      displaySavedPeers();
      console.log(`Cleaned up ${removedCount} invalid peers`);
      
      return { removedCount, remainingCount: Object.keys(validPeers).length };
    };
    
    // Remove offline peers
    window.removeOfflinePeers = function() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const onlinePeers = {};
      let removedCount = 0;
      
      for (const [peerId, peer] of Object.entries(savedPeers)) {
        if (peer.online !== false) {
          onlinePeers[peerId] = peer;
        } else {
          removedCount++;
          console.log(`Removing offline peer: ${peer.peerName} (${peerId})`);
        }
      }
      
      localStorage.setItem(savedPeersKey, JSON.stringify(onlinePeers));
      displaySavedPeers();
      console.log(`Removed ${removedCount} offline peers`);
      
      return { removedCount, remainingCount: Object.keys(onlinePeers).length };
    };
    
    // Function to refresh saved peers data
    async function refreshSavedPeers() {
      console.log('=== REFRESH FUNCTION CALLED ===');
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const updatedPeers = {};
      let totalRewardChange = 0;
      let totalWinChange = 0;
      
      console.log('Starting refresh of saved peers:', Object.keys(savedPeers));
      
      for (const [peerId, peer] of Object.entries(savedPeers)) {
        try {
          console.log(`Refreshing peer: ${peer.peerName} (${peerId})`);
          
          // Fetch latest peer data
          const url = `https://dashboard.gensyn.ai/api/v1/peer?id=${peerId}`;
          console.log('=== URL DEBUG ===');
          console.log('Calling URL:', url);
          console.log('Peer ID:', peerId);
          const peerData = await fetchWithCorsProxy(url);
          
          console.log('=== PEER DATA DEBUG ===');
          console.log('Peer data received:', peerData);
          console.log('Peer data type:', typeof peerData);
          console.log('Peer data keys:', peerData ? Object.keys(peerData) : 'null/undefined');
          console.log('Has peerId?', peerData && peerData.peerId ? 'YES' : 'NO');
          console.log('peerId value:', peerData && peerData.peerId);
          console.log('Raw peerData string:', JSON.stringify(peerData));
          console.log('Validation check:', peerData && peerData.peerId ? 'PASS' : 'FAIL');
          
          // CRITICAL TEST - This will definitely show up
          if (peerData) {
            console.log('CRITICAL: peerData exists');
            console.log('CRITICAL: peerData.peerId =', peerData.peerId);
            console.log('CRITICAL: peerData.reward =', peerData.reward);
            console.log('CRITICAL: peerData.score =', peerData.score);
          } else {
            console.log('CRITICAL: peerData is null/undefined');
          }
          
          console.log('=== END DEBUG ===');
          
          // Simple test to verify data structure
          if (peerData) {
            console.log('TEST: peerData exists');
            console.log('TEST: peerData.peerId =', peerData.peerId);
            console.log('TEST: peerData.reward =', peerData.reward);
            console.log('TEST: peerData.score =', peerData.score);
          } else {
            console.log('TEST: peerData is null/undefined');
          }
          
          // Try to parse if it's a string
          if (typeof peerData === 'string') {
            try {
              const parsedData = JSON.parse(peerData);
              console.log('Parsed from string:', parsedData);
              if (parsedData && parsedData.peerId) {
                const newReward = parsedData.reward || 0;
                const newScore = parsedData.score || 0;
                // ... rest of the logic
                return;
              }
            } catch (e) {
              console.log('Failed to parse string:', e);
            }
          }
          
          // Validation successful
          console.log('Validation: SUCCESS');
          
          if (peerData && peerData.peerId) {
            const newReward = peerData.reward || 0;
            const newScore = peerData.score || 0;
            
            // Calculate changes
            const rewardChange = newReward - peer.reward;
            const scoreChange = newScore - peer.score;
            if (rewardChange !== 0 || scoreChange !== 0) {
              addHistoryEntry({
                peerId: peer.peerId,
                peerName: peer.peerName,
                eoa: peer.eoa,
                rewardDelta: rewardChange,
                winDelta: scoreChange,
                rewardAfter: newReward,
                scoreAfter: newScore
              });
            }
            
            // Update peer data
            updatedPeers[peerId] = {
              ...peer,
              reward: newReward,
              score: newScore,
              lastUpdated: Date.now(),
              online: true, // Mark as online since we got valid data
              changes: {
                reward: rewardChange,
                score: scoreChange
              }
            };
            
            // Add to total changes
            totalRewardChange += rewardChange;
            totalWinChange += scoreChange;
            
            console.log(`Peer ${peer.peerName}: Reward ${peer.reward} ‚Üí ${newReward} (${rewardChange > 0 ? '+' : ''}${rewardChange}), Score ${peer.score} ‚Üí ${newScore} (${scoreChange > 0 ? '+' : ''}${scoreChange})`);
          } else {
            console.log(`No valid peer data received for ${peer.peerName}, marking as offline`);
            console.log('Invalid peer data structure:', peerData);
            // Mark peer as offline if no valid response
            updatedPeers[peerId] = {
              ...peer,
              lastUpdated: Date.now(),
              online: false, // Mark as offline
              changes: {
                reward: 0,
                score: 0
              }
            };
          }
        } catch (error) {
          console.error(`Failed to refresh peer ${peer.peerName}:`, error);
          
          // Check if it's a 404 error (peer not found)
          const is404Error = error.message && error.message.includes('404');
          
          if (is404Error) {
            console.log(`Peer ${peer.peerName} not found (404), marking as offline`);
            updatedPeers[peerId] = {
              ...peer,
              lastUpdated: Date.now(),
              online: false, // Mark as offline
              changes: {
                reward: 0,
                score: 0
              }
            };
          } else {
            // Keep existing data for other types of errors
            updatedPeers[peerId] = {
              ...peer,
              lastUpdated: Date.now(),
              changes: {
                reward: 0,
                score: 0
              }
            };
          }
        }
      }
      
      console.log('Updated peers:', Object.keys(updatedPeers));
      
      // Safety check: ensure we have the same number of peers
      if (Object.keys(updatedPeers).length !== Object.keys(savedPeers).length) {
        console.error('WARNING: Peer count mismatch! Keeping original data.');
        console.log('Original peers:', Object.keys(savedPeers));
        console.log('Updated peers:', Object.keys(updatedPeers));
        return { totalRewardChange: 0, totalWinChange: 0 };
      }
      
      // Save updated peers
      localStorage.setItem(savedPeersKey, JSON.stringify(updatedPeers));
      
      // Update display
      displaySavedPeers();
      
      // Update slider with saved peers data
      displaySavedPeersSlider();
      
      // Show total changes in summary if any
      if (totalRewardChange !== 0 || totalWinChange !== 0) {
        showTotalChanges(totalRewardChange, totalWinChange);
      }
      
      // Clear changes after 5 seconds
      setTimeout(() => {
        clearPeerChanges();
      }, 5000);
      
      return { totalRewardChange, totalWinChange };
    }
    
    // Function to show total changes with animation
    function showTotalChanges(rewardChange, winChange) {
      const rewardsElement = document.getElementById('total-rewards');
      const winsElement = document.getElementById('total-wins');
      
      if (rewardChange > 0) {
        rewardsElement.style.animation = 'pulse 0.5s ease-in-out';
        rewardsElement.style.color = '#00ff88';
        setTimeout(() => {
          rewardsElement.style.color = 'var(--primary-color)';
          rewardsElement.style.animation = '';
        }, 1000);
      }
      
      if (winChange > 0) {
        winsElement.style.animation = 'pulse 0.5s ease-in-out';
        winsElement.style.color = '#00ff88';
        setTimeout(() => {
          winsElement.style.color = 'var(--primary-color)';
          winsElement.style.animation = '';
        }, 1000);
      }
    }
    
    // Function to clear peer changes
    function clearPeerChanges() {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      let hasChanges = false;
      
      for (const [peerId, peer] of Object.entries(savedPeers)) {
        if (peer.changes && (peer.changes.reward !== 0 || peer.changes.score !== 0)) {
          savedPeers[peerId] = {
            ...peer,
            changes: {
              reward: 0,
              score: 0
            }
          };
          hasChanges = true;
        }
      }
      
      if (hasChanges) {
        localStorage.setItem(savedPeersKey, JSON.stringify(savedPeers));
        displaySavedPeers();
        displaySavedPeersSlider();
        console.log('Cleared peer changes');
      }
    }
    
    // Function to show saved peer details
    function showSavedPeerDetails(peerId) {
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const peer = savedPeers[peerId];
      
      if (!peer) return;
      
      // Create modal or update search results
      const detailDiv = document.getElementById('peer-detail');
      detailDiv.style.display = 'block';
      
      detailDiv.innerHTML = `
        <div class="peer-card">
          <div class="peer-header">
            <div class="peer-avatar">${peer.peerName.charAt(0).toUpperCase()}</div>
            <div class="peer-info">
              <h3 class="peer-name">${peer.peerName}</h3>
              <span class="peer-status ${peer.online ? 'online' : 'offline'}">${peer.online ? 'üü¢ Online' : 'üî¥ Offline'}</span>
            </div>
          </div>
          <div class="peer-stats">
            <div class="stat-item-cool">
              <span class="stat-icon">üéÅ</span>
              <span class="stat-label-cool">Reward</span>
              <span class="stat-value-cool">${peer.reward.toLocaleString()}</span>
            </div>
            <div class="stat-item-cool">
              <span class="stat-icon">üèÜ</span>
              <span class="stat-label-cool">Wins</span>
              <span class="stat-value-cool">${peer.score.toLocaleString()}</span>
            </div>
          </div>
          <div class="peer-details">
            <div class="detail-item">
              <span class="detail-label">Peer ID</span>
              <span class="detail-value">${peer.peerId}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">EOA Address</span>
              <span class="detail-value">${peer.eoa || 'Not available'}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Last Updated</span>
              <span class="detail-value">${new Date(peer.lastUpdated).toLocaleString()}</span>
            </div>
            ${peer.changes.reward !== 0 ? `
            <div class="detail-item">
              <span class="detail-label">Reward Change</span>
              <span class="detail-value ${peer.changes.reward > 0 ? 'positive' : 'negative'}">${peer.changes.reward > 0 ? '+' : ''}${peer.changes.reward}</span>
            </div>
            ` : ''}
            ${peer.changes.score !== 0 ? `
            <div class="detail-item">
              <span class="detail-label">Score Change</span>
              <span class="detail-value ${peer.changes.score > 0 ? 'positive' : 'negative'}">${peer.changes.score > 0 ? '+' : ''}${peer.changes.score}</span>
            </div>
            ` : ''}
          </div>
          <div class="peer-footer">
            <span class="success-badge">‚úì Saved Peer Details</span>
          </div>
        </div>
      `;
      
      // Scroll to the details
      detailDiv.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Make showSavedPeerDetails globally accessible
    window.showSavedPeerDetails = showSavedPeerDetails;
    
    // Update saved peers with rate limiting (every 15 minutes)
    async function updateSavedPeers() {
      console.log('=== UPDATE FUNCTION CALLED ===');
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      const peerIds = Object.keys(savedPeers);
      
      if (peerIds.length === 0) return;
      
      // Check rate limit for saved peers updates
      if (isRateLimited('savedPeersUpdate')) {
        console.log('Saved peers update rate limited');
        return;
      }
      
      console.log(`Updating ${peerIds.length} saved peers...`);
      
      const updatedPeers = {};
      let totalRewardChange = 0;
      let totalWinChange = 0;
      
      for (const peerId of peerIds) {
        try {
          const peerData = await fetchWithCorsProxy(`https://dashboard.gensyn.ai/api/v1/peer?id=${peerId}`);
          
          // Update validation successful
          console.log('Update validation: SUCCESS');
          
          if (peerData && peerData.peerId) {
            const peer = savedPeers[peerId];
            const newReward = peerData.reward || 0;
            const newScore = peerData.score || 0;
            // Ensure we keep or populate EOA
            let eoaToUse = peer.eoa && peer.eoa !== '0x0000000000000000000000000000000000000000' ? peer.eoa : null;
            if (!eoaToUse) {
              try { eoaToUse = await fetchEoaForPeerId(peerId); } catch (_) { /* noop */ }
            }
            
            // Calculate changes
            const rewardChange = newReward - peer.reward;
            const scoreChange = newScore - peer.score;
            if (rewardChange !== 0 || scoreChange !== 0) {
              addHistoryEntry({
                peerId: peer.peerId,
                peerName: peer.peerName,
                eoa: eoaToUse || peer.eoa,
                rewardDelta: rewardChange,
                winDelta: scoreChange,
                rewardAfter: newReward,
                scoreAfter: newScore
              });
            }
            
            // Update peer data
            updatedPeers[peerId] = {
              ...peer,
              reward: newReward,
              score: newScore,
              lastUpdated: Date.now(),
              online: true, // Mark as online since we got valid data
              eoa: eoaToUse || peer.eoa,
              changes: {
                reward: rewardChange,
                score: scoreChange
              }
            };
            
            // Add to total changes
            totalRewardChange += rewardChange;
            totalWinChange += scoreChange;
            
            console.log(`Auto-update peer ${peer.peerName}: Reward ${peer.reward} ‚Üí ${newReward} (${rewardChange > 0 ? '+' : ''}${rewardChange}), Score ${peer.score} ‚Üí ${newScore} (${scoreChange > 0 ? '+' : ''}${scoreChange})`);
          } else {
            console.log(`No valid peer data received for ${savedPeers[peerId].peerName}, marking as offline`);
            // Mark peer as offline if no valid response
            updatedPeers[peerId] = {
              ...savedPeers[peerId],
              lastUpdated: Date.now(),
              online: false, // Mark as offline
              changes: {
                reward: 0,
                score: 0
              }
            };
          }
        } catch (err) {
          console.error(`Error updating peer ${peerId}:`, err);
          
          // Check if it's a 404 error (peer not found)
          const is404Error = err.message && err.message.includes('404');
          
          if (is404Error) {
            console.log(`Peer ${savedPeers[peerId].peerName} not found (404), marking as offline`);
            updatedPeers[peerId] = {
              ...savedPeers[peerId],
              lastUpdated: Date.now(),
              online: false, // Mark as offline
              changes: {
                reward: 0,
                score: 0
              }
            };
          } else {
            // Keep existing data for other types of errors
            updatedPeers[peerId] = savedPeers[peerId];
          }
        }
        
        // Small delay between requests to be respectful
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      // Save updated peers
      localStorage.setItem(savedPeersKey, JSON.stringify(updatedPeers));
      
      // Update display
      displaySavedPeers();
      
      // Update slider with saved peers data
      displaySavedPeersSlider();
      
      // Show total changes in summary if any
      if (totalRewardChange !== 0 || totalWinChange !== 0) {
        showTotalChanges(totalRewardChange, totalWinChange);
      }
      
      // Clear changes after 5 seconds
      setTimeout(() => {
        clearPeerChanges();
      }, 5000);
      
      // Set rate limit after updating all peers
      setRateLimit('savedPeersUpdate');
      console.log('Saved peers updated successfully');
    }
    
    // Update saved peers every 5 minutes for more frequent updates
    setInterval(updateSavedPeers, 5 * 60 * 1000); // 5 minutes
    
    // Fetch stats on page load
    fetchNetworkStats();
    
    // Display saved peers on page load
    displaySavedPeers();
    
    // Update saved peers data immediately on page load
    console.log('=== CALLING INITIAL UPDATE ===');
    updateSavedPeers();
    
    // --- Display saved peers in slider ---
    function displaySavedPeersSlider() {
      const sliderDiv = document.getElementById('rewards-slider');
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      
      sliderDiv.style.display = 'block';
      
      if (Object.keys(savedPeers).length === 0) {
        sliderDiv.innerHTML = '<span class="reward-item">No saved peers yet. Search for peers to track them!</span>';
        return;
      }
      
      // Sort peers by reward (highest first) and include all, filter out invalid peers
      const sortedPeers = Object.values(savedPeers)
        .filter(peer => peer && peer.peerName && peer.reward !== undefined)
        .sort((a, b) => b.reward - a.reward)
        ;
      
      const rewardsHtml = sortedPeers.map(peer => {
        const changeIndicator = peer.changes && peer.changes.reward !== 0 
          ? ` <span style="color: ${peer.changes.reward > 0 ? '#00ff88' : '#ff4757'}; font-weight: bold;">(${peer.changes.reward > 0 ? '+' : ''}${peer.changes.reward})</span>`
          : '';
        
        return `<span class="reward-item">${peer.peerName} - ${peer.reward.toLocaleString()}${changeIndicator}</span>`;
      }).join(' ');
      
      sliderDiv.innerHTML = rewardsHtml;
    }
    
    // Display saved peers slider on page load and update when peers change
    displaySavedPeersSlider();
    
    // Email Modal Functions
    function openEmailModal() {
      document.getElementById('email-modal').style.display = 'block';
    }

    function closeEmailModal() {
      document.getElementById('email-modal').style.display = 'none';
    }

    function savePeersToFile() {
      const fileName = document.getElementById('file-name').value.trim();
      if (!fileName) {
        document.getElementById('email-status').textContent = 'Please enter a file name.';
        document.getElementById('email-status').style.color = 'red';
        return;
      }
      
      const savedPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
      if (Object.keys(savedPeers).length === 0) {
        document.getElementById('email-status').textContent = 'No peers to save!';
        document.getElementById('email-status').style.color = 'orange';
        return;
      }
      
      const peersToSave = Object.values(savedPeers).map(peer => ({
        peerId: peer.peerId,
        peerName: peer.peerName,
        reward: peer.reward,
        score: peer.score,
        online: peer.online,
        lastUpdated: peer.lastUpdated,
        changes: peer.changes
      }));

      try {
        const data = {
          savedPeers: peersToSave,
          savedAt: new Date().toISOString(),
          totalPeers: peersToSave.length
        };
        const jsonData = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${fileName}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        document.getElementById('email-status').textContent = `‚úÖ Saved ${peersToSave.length} peers as ${fileName}.json`;
        document.getElementById('email-status').style.color = 'green';
      } catch (err) {
        document.getElementById('email-status').textContent = `‚ùå Error saving file: ${err.message}`;
        document.getElementById('email-status').style.color = 'red';
      }
    }

    function loadPeersFromFile() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        try {
          const text = await file.text();
          const loadedData = JSON.parse(text);
          
          // Handle both old format (email/peers) and new format (savedPeers)
          let peers = [];
          if (loadedData.savedPeers) {
            peers = loadedData.savedPeers;
          } else if (loadedData.peers) {
            peers = loadedData.peers;
          } else {
            throw new Error('Invalid file format');
          }

          const existingPeers = JSON.parse(localStorage.getItem(savedPeersKey) || '{}');
          let addedCount = 0;
          let updatedCount = 0;

          for (const peer of peers) {
            if (existingPeers[peer.peerId]) {
              // Update existing peer
              const oldData = existingPeers[peer.peerId];
              const rewardChange = peer.reward - oldData.reward;
              const scoreChange = peer.score - oldData.score;
              existingPeers[peer.peerId] = {
                ...peer,
                lastUpdated: new Date().toISOString(),
                previousData: {
                  reward: oldData.reward,
                  score: oldData.score,
                  lastUpdated: oldData.lastUpdated
                },
                changes: {
                  reward: rewardChange,
                  score: scoreChange
                }
              };
              updatedCount++;
            } else {
              // New peer
              existingPeers[peer.peerId] = {
                ...peer,
                lastUpdated: new Date().toISOString(),
                previousData: null,
                changes: {
                  reward: 0,
                  score: 0
                }
              };
              addedCount++;
            }
          }
          
          localStorage.setItem(savedPeersKey, JSON.stringify(existingPeers));
          displaySavedPeers();
          
          let message = '';
          if (addedCount > 0 && updatedCount > 0) {
            message = `‚úÖ Added ${addedCount} new peers and updated ${updatedCount} existing peers`;
          } else if (addedCount > 0) {
            message = `‚úÖ Added ${addedCount} new peers`;
          } else if (updatedCount > 0) {
            message = `‚úÖ Updated ${updatedCount} existing peers`;
          } else {
            message = '‚úÖ File loaded but no changes made';
          }
          
          document.getElementById('email-status').textContent = message;
          document.getElementById('email-status').style.color = 'green';
        } catch (err) {
          document.getElementById('email-status').textContent = `‚ùå Error loading file: ${err.message}`;
          document.getElementById('email-status').style.color = 'red';
        }
      };
      input.click();
    }

    // Close modal if user clicks outside
    window.onclick = function(event) {
      const emailModal = document.getElementById('email-modal');
      if (event.target == emailModal) {
        closeEmailModal();
      }
    }
    
    // Debug: Check if elements exist
    console.log('Debug: Checking elements...');
    console.log('Top rewards banner:', document.getElementById('top-rewards-banner'));
    console.log('Rewards slider:', document.getElementById('rewards-slider'));
    console.log('Search form:', document.getElementById('search-form'));
    console.log('Saved peers section:', document.getElementById('saved-peers'));
  </script>
  <script>
    (function () {
      if (!window.anime) return; // Fail-safe if CDN fails

      function initFloatingShapes() {
        const container = document.getElementById('fx-shapes');
        if (!container) return;
        const numShapes = 10;
        const variants = ['s1', 's2', 's3', 's4'];
        for (let i = 0; i < numShapes; i++) {
          const el = document.createElement('div');
          el.className = `fx-shape ${variants[i % variants.length]}`;
          el.style.left = Math.random() * 100 + 'vw';
          el.style.top = Math.random() * 100 + 'vh';
          el.style.transform = `translate(-50%, -50%) scale(${0.6 + Math.random() * 1.2}) rotate(${Math.random() * 360}deg)`;
          container.appendChild(el);
          anime({
            targets: el,
            translateX: () => anime.random(-150, 150),
            translateY: () => anime.random(-120, 120),
            rotate: () => anime.random(-180, 180),
            direction: 'alternate',
            duration: () => anime.random(6000, 12000),
            delay: anime.stagger(200, { start: i * 80 }),
            easing: 'easeInOutSine',
            loop: true,
            autoplay: true
          });
        }
      }

      function heroIntro() {
        const title = document.querySelector('header h1');
        const toggle = document.getElementById('theme-toggle');
        anime.timeline({ easing: 'easeOutQuad' })
          .add({ targets: title, translateY: [20, 0], opacity: [0, 1], duration: 500 })
          .add({ targets: toggle, scale: [0.9, 1], opacity: [0, 1], duration: 250 }, '-=300');
      }

      function heroTextAnimation() {
        const hero = document.querySelector('.hero-title');
        if (!hero) return;
        const text = hero.textContent.trim();
        hero.innerHTML = text.split('').map((ch) => `<span class="letter">${ch === ' ' ? '&nbsp;' : ch}</span>`).join('');
        const letters = hero.querySelectorAll('.letter');
        anime.timeline({ loop: false })
          .add({
            targets: letters,
            translateY: [20, 0],
            opacity: [0, 1],
            easing: 'easeOutExpo',
            duration: 700,
            delay: anime.stagger(25)
          });
        const subtitle = document.querySelector('.hero-subtitle');
        if (subtitle) anime({ targets: subtitle, opacity: [0, 1], translateY: [10, 0], duration: 500, easing: 'easeOutQuad', delay: 300 });
        const heroSearch = document.querySelector('.hero-search');
        if (heroSearch) anime({ targets: heroSearch, opacity: [0, 1], translateY: [10, 0], duration: 450, easing: 'easeOutQuad', delay: 350 });
      }

      const countAnimating = new WeakSet();
      function animateCount(el, toValue) {
        if (!el) return;
        if (countAnimating.has(el)) return;
        const from = Number(el.dataset.countValue || el.textContent.replace(/[^0-9.-]/g, '') || 0);
        const to = Number(toValue || 0);
        if (!isFinite(to) || from === to) return;
        const obj = { val: from };
        countAnimating.add(el);
        anime({
          targets: obj,
          val: to,
          round: 1,
          easing: 'easeOutExpo',
          duration: 800,
          update: () => {
            el.textContent = Number(obj.val).toLocaleString();
          },
          complete: () => {
            el.dataset.countValue = String(to);
            countAnimating.delete(el);
          }
        });
      }

      function wireCountObservers() {
        const rewards = document.getElementById('total-rewards');
        const wins = document.getElementById('total-wins');
        const observer = new MutationObserver(() => {
          const r = Number((rewards && rewards.textContent || '0').replace(/[^0-9.-]/g, ''));
          const w = Number((wins && wins.textContent || '0').replace(/[^0-9.-]/g, ''));
          if (rewards) animateCount(rewards, r);
          if (wins) animateCount(wins, w);
        });
        if (rewards) observer.observe(rewards, { childList: true, characterData: true, subtree: true });
        if (wins) observer.observe(wins, { childList: true, characterData: true, subtree: true });
      }

      function revealOnScrollSetup() {
        const io = new IntersectionObserver((entries) => {
          entries.forEach((e) => {
            if (e.isIntersecting) {
              anime({ targets: e.target, translateY: [14, 0], opacity: [0, 1], duration: 500, easing: 'easeOutQuad' });
              io.unobserve(e.target);
            }
          });
        }, { threshold: 0.08 });

        const markAndObserve = (selector) => {
          document.querySelectorAll(selector).forEach((el) => {
            el.style.opacity = '0';
            el.style.transform = 'translateY(14px)';
            io.observe(el);
          });
        };
        markAndObserve('.saved-peer-card, .peer-card, .gensyn-leaderboard-row');
      }

      // Minimal DOM helpers
      const $$ = (selector, root = document) => Array.from(root.querySelectorAll(selector));
      const $ = (selector, root = document) => root.querySelector(selector);

      // removed experimental scroll peers builder

      function wireDynamicContainers() {
        // Stagger in leaderboard rows whenever content updates
        const leaderboard = document.getElementById('leaderboard-content');
        const peersContainer = document.getElementById('saved-peers-content');
        const makeStagger = (rowsSelector) => {
          const rows = document.querySelectorAll(rowsSelector);
          anime({
            targets: rows,
            opacity: [0, 1],
            translateY: [10, 0],
            translateX: [12, 0],
            scale: anime.stagger([1, 0.98], { from: 'center' }),
            delay: anime.stagger(60),
            duration: 460,
            easing: 'easeOutQuad'
          });
        };
        if (leaderboard) {
          new MutationObserver((mutations) => {
            const needs = mutations.some(m => m.type === 'childList' && (m.addedNodes.length || m.removedNodes.length));
            if (needs) makeStagger('#leaderboard-content .gensyn-leaderboard-row');
          }).observe(leaderboard, { childList: true });
        }
        if (peersContainer) {
          new MutationObserver((mutations) => {
            // Only animate when cards are added/removed, not when text inside changes (e.g., Copy ‚Üí Copied)
            const needs = mutations.some(m => m.type === 'childList' && (m.addedNodes.length || m.removedNodes.length));
            if (needs) makeStagger('#saved-peers-content .saved-peer-card');
          }).observe(peersContainer, { childList: true });
        }
      }

      // Subtle reactive tilt and parallax on hover
      function wireCardReactivity() {
        const grid = document.querySelector('.saved-peers-grid');
        if (!grid) return;
        const handleMove = (card, e) => {
          const rect = card.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width;  // 0..1
          const y = (e.clientY - rect.top) / rect.height; // 0..1
          const rx = (0.5 - y) * 4; // tilt range
          const ry = (x - 0.5) * 6;
          card.style.setProperty('--rx', rx + 'deg');
          card.style.setProperty('--ry', ry + 'deg');
          card.style.setProperty('--mx', Math.round(x * 100) + '%');
          card.style.setProperty('--my', Math.round(y * 100) + '%');
        };
        grid.addEventListener('mousemove', (e) => {
          const card = e.target.closest && e.target.closest('.saved-peer-card');
          if (card) handleMove(card, e);
        });
        grid.addEventListener('mouseleave', () => {
          document.querySelectorAll('.saved-peer-card').forEach(card => {
            card.style.setProperty('--rx', '0deg');
            card.style.setProperty('--ry', '0deg');
          });
        });
      }

      function init() {
        initFloatingShapes();
        heroIntro();
        heroTextAnimation();
        // initHeroSquares removed
        wireCountObservers();
        revealOnScrollSetup();
        wireDynamicContainers();
        wireCardReactivity();
        setupActiveNav();
        // scroll demo removed; experimental scroll peers removed
        wireHeroSearch();
      }

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(init, 0);
      } else {
        document.addEventListener('DOMContentLoaded', init);
      }
      
      function setupActiveNav() {
        const links = Array.from(document.querySelectorAll('.site-nav .nav-links a'));
        if (!links.length) return;
        const sections = links.map(a => document.querySelector(a.getAttribute('href'))).filter(Boolean);
        const io = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const id = '#' + (entry.target.id || '');
            const link = links.find(a => a.getAttribute('href') === id);
            if (link) {
              if (entry.isIntersecting) {
                links.forEach(l => l.classList.remove('active'));
                link.classList.add('active');
              }
            }
          });
        }, { rootMargin: '-40% 0px -55% 0px', threshold: 0.01 });
        sections.forEach(sec => io.observe(sec));
      }
      
      function wireHeroSearch() {
        const form = document.getElementById('hero-search-form');
        const input = document.getElementById('hero-search-input');
        const mainInput = document.getElementById('search-input');
        const mainForm = document.getElementById('search-form');
        if (!form || !input || !mainInput || !mainForm) return;
        form.addEventListener('submit', (e) => {
          e.preventDefault();
          const q = input.value.trim();
          if (!q) return;
          mainInput.value = q;
          mainForm.dispatchEvent(new Event('submit'));
          const target = document.getElementById('peer-search');
          if (target) window.scrollTo({ top: target.offsetTop - 20, behavior: 'smooth' });
        });
      }

      // hero squares removed
    })();
  </script>
</body>
</html>